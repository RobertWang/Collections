> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/cwlaikGS_URHjV7IX5v0Mw)

> 什么是协程？ 协程，又被称为轻量级线程，是一种用户态的，可并发执行的函数，并且可以在任何地方暂

**什么是协程？**  

        协程，又被称为轻量级线程，是一种用户态的，可并发执行的函数，并且可以在任何地方暂停执行，之后从暂停处继续执行。

与线程相比，协程最大的优势在于其 “轻量级”，可以轻易创建和销毁，且创建和销毁的开销非常小。在一些提供了协程概念的编程语言中，比如 Lua、Python 和 Go，甚至可以在单个程序中同时运行上万个甚至上亿个协程，而线程的数量常常受制于系统资源。

此外，协程的另一个重要特性是其调度完全由用户控制，协程的调度更为灵活，并且只在让出（yield）点进行，不会像线程那样存在抢占式调度。

Python、JavaScript、Go、Lua 等许多现代编程语言都内置了协程。语言如 Go, 在语言层面上提供了更为原生的协程支持（在 Go 语言中被称为 goroutine）。然而，它们在使用和行为上各不相同，提供了不同的并发编程模型。

协程在处理 IO 密集型任务和实现并发编程等方面展示了很强的能力，并且随着并发编程的日益重要，其在编程中的应用也越来越广泛。

**Go 中最早的协程调度器**

在 Go 语言的最早版本中，协程调度器（Goroutine Scheduler）的模型较为简单，它是基于协作式的非抢占式调度。在这个模型中，一个 Goroutine 在主动放弃 CPU（如通过系统调用或者 channel 操作）之前，会一直占用 CPU。这种设计简单易于理解，也能适应大部分场景。

然而，这个简单的协程调度器也有几个限制：

1.  公平性问题：由于当时 Go 使用的是非抢占式的调度机制，若一个 Goroutine 在循环等 CPU 密集型操作中不断运行，其他 Goroutine 就会饿死（无法得到执行），这也被称为 “公平性问题”。
    
2.  密集型任务的效率问题：在 CPU 密集型任务中，当创建的 Goroutine 数量大于 CPU core 数量时，频繁的 Goroutine 切换可能导致效率降低。
    
3.  全局锁问题：早期的版本中，所有的 Goroutine 由一个全局的队列进行管理，而为了线程安全，全局队列的操作需要加锁，这在大量并发时会成为性能瓶颈。
    

为了克服这些限制，Go 语言的 Goroutine 调度器在后续版本中进行了一系列的优化和改进，比如引入了 P（Processor）的概念，做到了 Goroutine 的本地队列管理；引入了 work stealing 和 hand off 等策略来提高调度的效率等。这使得 Go 语言的 Goroutine 调度器更加成熟和高效，能适应更多的并发场景。

**Go 中的协程调度器  
**

Go 语言的调度器是一种 M:N 的调度器，采用 M 个 Goroutine（协程）分别运行在 N 个 OS 线程上。Go 语言调度器的设计参考了操作系统中的进程 / 线程调度。

*   G：指代一个 Goroutine，也即 Go 语言中的协程。
    
*   M：指代一个 OS 线程。
    
*   P：被称为处理器。P 的数量是由 GOMAXPROCS 这个环境变量决定的，它决定了可以并发执行 Goroutine 的数量。
    

Go 调度器的运行流程如下：

1.  Goroutine 创建：创建 goroutine 时，会将新的 G 存放到 P 的运行队列里。如果 P 的数量没有达到 GOMAXPROCS，会创建新的 P 来运行 G；否则，Goroutine 会等待轮到它执行时再唤醒并运行。
    
2.  Goroutine 运行：如果 G 需要运行，调度器会从线程池中取一个 M，让 M 去运行这个 G。如果没有空闲线程 M，则会新建一个线程。
    
3.  系统调用：在 Goroutine 发起阻塞式的系统调用时，绑定的线程 M 会和 Goroutine G 分离，同时调度器创建或获取另一个线程 M，并在 M 上调度其他 Goroutine。
    
4.  Goroutine 结束：Goroutine 在结束时，会将其占用的线程 M 返回给线程池。
    
5.  负载均衡：Go 调度器会定期进行全局调度，从全局 P 对 G 进行重新调度，以保证平衡负载，防止某些 P 上积压过多的 G