> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/xsntnx4nhMCHdeyzLK5-sA)

> 实时排序 - topN 排行榜需求根据规则实时排序，比如根据焦点主频，共享屏幕，开关麦，开关视频，角色，声音等状态

需求
--

根据规则实时排序，比如根据焦点主频，共享屏幕，开关麦，开关视频，角色，声音等状态实时排序，返回 topN 用户。

因为我这边项目是视频会议，所以状态都是通过 RTC 回调通知我的，当然还有一部分是客户端回调我的，另外一小部分是通过信令实现的。因此我要根据这些回调，信令实时触发 topN 的计算。

设计方案
----

因为涉及到实时排序，第一个想到的就是`redis`的`zset`。那么接下来就应该设计 key 和 score。

`key：screen：{roomID}`

`score: 19位 [音频1位][音量3位][视频1位][角色1位][时间戳(ms)13位]`

1.  音频：1: 关 2: 开
    
2.  音量：0-999【3 位，数字越大，音量越大；取值 [0-999]】
    
3.  视频：1: 关 2: 开
    
4.  角色：4: 主持人 3: 联席主持人 2: 嘉宾 1: 学员（播控、挑屏、会议助理不参与排序，按照角色 id 从大到小排序）
    
5.  时间戳：回调时间戳
    

每个人会有一个分数，会利用 19 位组成一个分数，利用`redis` `zset`进行排序，取分数最高的 N 个人。比如：用户 1234 的分是 2100141111111111111（主持人 1234，开了音频，音量是 100，关了视频，在 1111111111111 这个时间）。

当客户端或者 RTC 回调或者信令到达的时候，不断计算分数实现实时计算排序。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/OFoSeMttJpaUT2hAdlo4zf31O9u1RpCRRP8OUlsb8b7vzOV1J3vEvXFcEdq9n90lKt3sO4CRHxkC9SjZdCPWNQ/640?wx_fmt=png)架构图

因为是几万人的会议，回调数据量非常大，就用 kafka 作为消息中间件。

优化
--

因为每次根据回调实时计算排序的结果不同，那么导致会议中 topN 窗口中的人会实时切换画面，导致体验不好。因此要实现一个相对稳定排序算法。

稳定性排序算法步骤如下：稳定性算法 (6 步骤)：

1.  通过排序之后获取 top 7 成员存储到 redis 中
    
2.  等下次排序计算之后获取新的 top 7 成员 我们记为 B
    
3.  从 redis 获取最后一次 top 7 的成员 我们记为 A
    
4.  通过排序算法计算 A&B 的的相对稳定集合 我们记为 C
    
5.  存储 C 到最后一次 top 7 缓存中
    
6.  返回 C
    

步骤 4 排序算法核心思想：两个有序集合 A，B，如果成员存在 A 中但不存在 B 中，那么删除 A 中的此成员；如果成员既存在 A 中也存在 B 中，那么删除 B 中的此成员。等这两个步骤执行完成之后，将 A 中有空位的地方用 B 去填充，切记 B 中的元素是有序地按照 A 中空缺的位置挨个填充的。如果 A 中没有剩余位置，那么代表结果已经满足 top 7，可以正常结束算法了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/OFoSeMttJpaUT2hAdlo4zf31O9u1RpCRkvExFnzoNYa8XhtFtd4hXf2kictp6lq1IyVqHRfDaibjV0m06qibMMoSA/640?wx_fmt=png)

总结
--

技术细节如下：

1.  计算排序规则✅
    
2.  接受信令以及所有回调✅
    
3.  所有的回调按照 WAL 技术先落地日志✅
    
4.  实现统一的回调转发服务，所有信息透传✅
    
5.  根据 room_id 区分是线上 测试 灰度还是 demo✅
    
6.  布局以及其他录制参数存储到 redis 中或者本地代码中✅
    
7.  多人点击录制 / 关闭按钮，只有一个人是成功的, 加分布式锁✅
    
8.  回调都是进入 kafka，然后按需消费✅
    
9.  kafka topic 区分线上 测试 demo 灰度✅
    
10.  监控 kafka topic 队列状况，防止回调信息处理不及时✅
    
11.  异常情况统一归并处理✅