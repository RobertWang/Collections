> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/YULhLroeAwTBdsqk-i4z5w)

反射是什么？

*   反射是运行时检查自身结构的机制。
    
*   反射是困惑的源泉。
    

Go 语言的反射是一种强大且复杂的特性，允许我们创造更灵活、更动态的代码。但是，理解和妥善使用反射也需要一定的技巧。

因此，在本文中，我们将深入探讨 Go 语言的反射，包括其基本概念，原理，使用方式，以及常见的陷阱和提示。

### 一、反射的基本概念

#### 1.1 测验题目

**题目一**  
如何判断 Person 结构中的两个变量是否相等？是否可以使用 “==” 操作符进行比较？

```
type Person struct {
    Name string
    Age int
    extra interface{}
}


```

**答案**：使用 “==” 操作符可以比较两个结构体变量，但仅限于结构体成员类型是简单类型，不能比较诸如 slice、map 等不可比较类型。

实际项目中常常使用 `reflect.DeepEqual()` 函数来比较两个结构体变量，它支持任意两个结构体变量的比较，详细实例如下：

```
package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name  string
    Age   int
    extra interface{}
}

func main() {
    p1 := &Person{
        Name:  "姓名1",
        Age:   20,
        extra: "{}",
    }
    p2 := p1
    p3 := &Person{
        Name:  "姓名1",
        Age:   20,
        extra: "{}",
    }

    // 内存地址相同：true
    fmt.Println("p1 == p2 :", p1 == p2)
    // reflect.DeepEqual 支持任意两个结构体变量的比较，结构体每个值都相同，所以为 true
    fmt.Println("p1 DeepEqual p2 :", reflect.DeepEqual(p1, p2))

    // 内存地址不相同：false
    fmt.Println("p1 == p3 :", p1 == p3)
    // reflect.DeepEqual 支持任意两个结构体变量的比较，结构体每个值都相同，所以为 true
    fmt.Println("p1 DeepEqual p3 :", reflect.DeepEqual(p1, p3))
}


```

####   

#### 1.2 接口概念

反射在计算机科学中是一种程序在运行时查看和修改自身结构和行为的能力。在 Go 语言中，reflect 包提供了一组函数，用于在运行时查看类型和值，修改值，以及调用方法。

在了解反射之前先了解一下类型和接口。

**类型**  
我们都知道 Go 语言是静态类型语言，比如 int、float32、[]byte 等等，每个变量都有一个静态类型，在代码编译时就已经确定了。

请问变量 i 和 j 是相同的类型吗？

```
type Myint int 

var i int 
var j Myint


```

答案：变量 i 和 j 是不同的类型，二者拥有不同的静态类型，尽管二者的底层类型都是 int，但是在没有类型转换的情况下是不可以互相赋值的。

**interface 类型**  
每一个 interface 类型代表一个特定的方法集，方法集中的方法被称为接口。比如：  
Person 就是一个接口类型，其中包含了一个 Speak() 方法。

```
type Person interface {
    Speak() string
}


```

**interface 变量**  
就像任何其他类型一样，我们也可以声明 interface 类型变量，比如：

```
// 因为没有给 wj 赋值，所以它是 nil
var wj Person


```

**实现接口**  
任何类型只要实现了 interface 类型的所有方法，就可以声称该类型实现了该接口，该类的变量就可以存储到 interface 类型的变量中。

```
type Teacher struct {

}

func (c Teacher) Speak() string {
    return "teach teach teach"
}


```

此时，结构体 Teacher 就可以存储到 wj 变量中：

```
var wj Person
var teacher Teacher
wj = teacher


```

实际上，interface 变量可以存储任意实现了该接口类型的变量。

**复合类型**  
为什么 interface 变量可以存储任意实现了该接口类型的变量呢？

**原因**：interface 类型的变量在存储某个变量时会同时保存变量类型和变量值，Go 运行时会将 interface 类型表示成如下：

```
type iface struct {
    tab *itab // 保存变量类型以及方法集
    data unsafe.Pointer // 变量值位于堆栈的指针
}


```

我们暂时只需要明白：interface 变量同时保存了变量值和变量类型即可。终于要引出今天分享的核心内容了。

Go 的反射就是在运行时操作 interface 中的值和类型的特性，这是理解反射的前提。

**特殊空 interface**

空 interface 是一种非常特殊的 interface 类型，因为它没有指定任何方法集，如此一来，任意类型都可以声称实现了空接口，那么该接口类型就可以存储任意类型的值了。

```
var emptyIf interface {

}


```

###   

### 二、反射原理

#### 2.1 Type 和 Value

在 Go 的反射机制中，最重要的两个概念是 Type（类型）和 Value（值）。每个在 Go 语言中声明的变量都有一个类型和值。我们可以通过 reflect.TypeOf 和 reflect.ValueOf 函数来获取变量的类型和值。

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 7
    t := reflect.TypeOf(x)
    v := reflect.ValueOf(x)
    fmt.Printf("Type: %v\n", t)  // Type: int
    fmt.Printf("Value: %v\n", v) // Value: 7
}


```

在这个例子中，我们首先声明了一个 int 类型的变量 x，然后使用 reflect.TypeOf 和 reflect.ValueOf 函数获取 x 的类型和值，并打印出来。

reflect 包中同时提供了两个方法来提取 interface 和 value 类型：

```
func ValueOf(i interface) Value

func TypeOf(i interface) Type 


```

![](https://mmbiz.qpic.cn/mmbiz_jpg/ib5vRCrBRAkVpz3qIk6VTJRBn8dibcR7o938Qpibd3sB0b848DEOzGIlr9JQFCPoALia1QnauxeTWXrvLMP30u63fA/640?wx_fmt=jpeg)

从上面可以知道，Go 语言的反射基于两种类型：Type 和 Value。每个 Type 表示一个 Go 语言的类型，它是一个接口，有许多方法用于检查类型的属性，例如它是不是一个指针，它的元素类型是什么等等。Value 类型表示一个 Go 语言的值，它是一个结构体，包含了一个表示值的接口和一个表示值类型的 Type。  

当我们通过 reflect.TypeOf 和 reflect.ValueOf 函数获取一个变量的类型和值时，实际上是创建了一个 Type 或 Value 的实例，这个实例包含了变量的类型信息或值信息。然后，我们可以通过 Type 或 Value 的方法来操作这个变量。

####   

#### 2.2 反射定律

第一定律：反射可以将 interface 类型变量转换为反射对象。  

例子来演示如何通过反射获取 interface 变量的值和类型：

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 7.1

    // 变量 x 在传入 reflect.TypeOf 函数时，实际上做了一次类型转换，x 被转换成空接口传入
    t := reflect.TypeOf(x)

    //  reflect.ValueO 函数亦是如此
    v := reflect.ValueOf(x)

    fmt.Printf("Type: %v\n", t)  // Type: float64
    fmt.Printf("Value: %v\n", v) // Value:  7.1
}


```

第二定律：反射可以将反射对象还原成 interface 对象。  

之所以 “反射”，是因为反射对象与 interface 对象是可以互相转化的，比如下面示例：

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var numIf interface{}
    numIf = 100

    v := reflect.ValueOf(numIf)
    vIf := v.Interface()

    if numIf == vIf {
        fmt.Printf("They are same!")
    }
}

// 打印输出
They are same!


```

第三定律：反射对象可修改， value 值必须是要先设置为可设置的。

先看看下面代码，通过反射对象 v 对象设置新值，会触发 panic：

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    numIf := 100

    v := reflect.ValueOf(&numIf)

    // reflect.ValueOf 获取的是其所存储的值，而非 v 本身，即通过 v 修改其值是无法影响 x 的，无效的修改会报 panic
    v.SetInt(1000)

    fmt.Println("v=", v.Elem().Interface())
}


```

  
![](https://mmbiz.qpic.cn/mmbiz_png/ib5vRCrBRAkVpz3qIk6VTJRBn8dibcR7o9dMWxuQlOse9IWUMI9mNV3ibkgVNSdvjNkaK3R1CWHeia79gYaRwoGZkg/640?wx_fmt=png)image.png

正确的写法：

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    numIf := 100

    v := reflect.ValueOf(&numIf)

    // Elem() 方法可以获取指向 v 的指针，可以成功设置
    v.Elem().SetInt(1000)

    fmt.Println("v=", v.Elem().Interface())
}


```

  
![](https://mmbiz.qpic.cn/mmbiz_png/ib5vRCrBRAkVpz3qIk6VTJRBn8dibcR7o9dtFkpALT00szbmrr2RJMBk6OZMgmzYLQCFvBTTrSLADl6psj2TXzhA/640?wx_fmt=png)image.png

###   

### 三、反射的其它使用

在 Go 语言中，我们可以通过反射来实现许多灵活和动态的功能。例如，我们可以通过反射来动态创建对象，动态调用方法，或者遍历和修改结构体的字段。

#### 3.1 动态创建对象

我们可以通过 reflect.New 函数来动态创建对象。reflect.New 函数接受一个 Type 参数，返回一个 Value，这个 Value 包含了一个指向新创建的对象的指针。

```
// 创建一个 int 的实例
t := reflect.TypeOf(int(0))
v := reflect.New(t)
fmt.Println(v.Elem().Int()) // 输出 0


```

在这个例子中，我们首先获取 int 类型的 Type，然后通过 reflect.New 函数创建一个新的 int 实例，并打印出它的值。

####   

#### 3.2 动态调用方法

我们可以通过 reflect.Value 的 Method 方法来获取一个方法的 Value，然后通过 Call 方法来调用这个方法。

```
type MyStruct struct {
}

func (m *MyStruct) MyMethod() {
    fmt.Println("MyMethod was called")
}

func main() {
    m := &MyStruct{}
    v := reflect.ValueOf(m)
    method := v.MethodByName("MyMethod")
    method.Call(nil)
}


```

在这个例子中，我们首先定义了一个结构体 MyStruct 和它的方法 MyMethod，然后通过反射获取 MyMethod 的 Value，并调用它。

####   

#### 3.3 遍历和修改结构体的字段

我们可以通过 reflect.Value 的 NumField 和 Field 方法来遍历一个结构体的所有字段，并通过 Set 方法来修改字段的值。

```
type MyStruct struct {
    Field1 int
    Field2 string
}

func main() {
    m := &MyStruct{Field1: 1, Field2: "hello"}
    v := reflect.ValueOf(m).Elem()

    for i := 0; i < v.NumField(); i++ {
        field := v.Field(i)
        fmt.Printf("Field %d: %v\n", i, field.Interface())

        if field.Kind() == reflect.Int {
            field.SetInt(2)
        } else if field.Kind() == reflect.String {
            field.SetString("world")
        }
    }

    fmt.Printf("m: %v\n", m)  // 输出：m: &{2 world}
}


```

在这个例子中，我们首先定义了一个结构体 MyStruct，然后通过反射遍历 MyStruct 的所有字段，打印出字段的值，并修改它们的值。

###   

### 四、常见的陷阱和提示

虽然反射是一个强大的工具，但是它也有一些陷阱和限制。

1.  对于不可导出的字段和方法，反射不能访问或修改它们。例如，我们不能通过反射来修改一个结构体的小写字段。
    
2.  使用反射会有一些性能开销。因为反射操作涉及到一些动态类型检查和方法调用，所以它通常比普通的静态类型操作要慢。
    
3.  反射代码通常比较难以理解和维护。因为反射操作往往涉及到一些动态类型和方法，所以它的代码往往比较难以理解和维护。
    

###   

### 五、总结

总的来说，Go 语言的反射是一个强大且复杂的特性。通过反射，我们可以实现更灵活、更动态的代码。但是，我们也需要注意反射的一些陷阱和限制。在使用反射时，我们需要权衡其灵活性和性能开销，以及代码的可读性和维护性。