> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Z-YSGIJli9z-1CAt26KAPg)

前言
--

> 今天想与大家聊一聊如何用`Go`实现装饰器代码。为什么会有这个想法呢？最近由于项目需要一直在看`python`的代码，在这个项目中应用了大量的装饰器代码，一个装饰器代码可以在全文共用，减少了冗余代码。`python`的语法糖让实现装饰器变得很简单，但是`Go`语言的`糖`不多，而且又是强类型的静态无虚拟机的语言，所以，没有办法做到像`Java` 和 `Python` 那样写出优雅的装饰器的代码，但也是可以实现的，今天我们就看看如何`Go`语言写出装饰器代码！

什么是装饰器
------

介绍装饰器基本概念之前，我们先举个例子，跟装饰器很贴切：

> 如今我们的生活水平提高了，基本人手一台手机，大家也知道手机屏幕摔到地板上是很容易碎屏的，手机屏幕一坏，又要多花一笔费用进行维修，很是心痛；那么有什么什么办法来避免这个问题呢，在不破坏手机屏幕结构的情况下，让我们的手机更耐坏呢？其实我们只需要花几元钱买一个钢化膜，钢化膜在不改变原有手机屏幕的结构下，让手机变得更耐摔了。

根据上面这个例子，就可以引出本文的核心 -> 装饰器。装饰器本质就是：

> 函数装饰器用于在源码中 “标记” 函数，以某种方式增强函数的行为。

装饰器是一个强大的功能，但是若想掌握，必须要理解闭包！闭包的概念我们在下面一小节说明，我们先来看一看`python`是如何使用装饰器的：

```
def metric(fn):
    @functools.wraps(fn)
    def timer(*arag, **kw):
        start = time.time()
        num = fn(*arag, **kw)
        end = time.time()
        times = (end - start) * 1000
        print('%s executed in %s ms' % (fn.__name__, times))
        return num
    return timer

@metric
def Sum(x, y):
    time.sleep(0.0012)
    return x + y;


Sum(10, 20)


```

这里要实现功能很简单，`metric`就是一个装饰器函数，他可以作用于任何函数之上，并打印该函数的执行时间，有个这个装饰器，我们想要知道任何一个函数的执行时间，就简便很多了。

简单总结一下装饰器使用场景：

*   插入日志：使面向切面编程变的更简单了。
    
*   缓存：读写缓存使用装饰器来实现，减少了冗余代码。
    
*   事务处理：使代码看起来更简洁了。
    
*   权限校验：权限校验器是都是一套代码，减少了冗余代码。
    

装饰器的使用场景还用很多，就不一一列举了，下面我们就来看看如何使用`Go`也来实现装饰器代码吧！

闭包
--

装饰器的实现和闭包是分不开的，所以我们先来学习一下什么是闭包！

```
func makeAverager() func(val float32) float32{
 series := make([]float32,0)
 return func(val float32) float32 {
  series = append(series, val)
  total := float32(0)
  for _,v:=range series{
   total +=v
  }
  return total/ float32(len(series))
 }
}

func main() {
 avg := makeAverager()
 fmt.Println(avg(10))
 fmt.Println(avg(30))
}


```

```
# command-line-arguments
test/test1.go:21:13: inlining call to fmt.Println
test/test1.go:22:13: inlining call to fmt.Println
test/test1.go:8:2: moved to heap: series
test/test1.go:8:16: make([]float32, 0) escapes to heap
test/test1.go:9:9: func literal escapes to heap
test/test1.go:21:17: avg(10) escapes to heap
test/test1.go:21:13: []interface {} literal does not escape
test/test1.go:22:17: avg(30) escapes to heap
test/test1.go:22:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape


```

Gin 中装饰器的应用
-----------

```
func VerifyHeader() gin.HandlerFunc {
 return func(c *gin.Context) {
  header := c.Request.Header.Get("token")
  if header == "" {
   c.JSON(200, gin.H{
    "code":   1000,
    "msg":    "Not logged in",
   })
   return
  }
 }
}
func main()  {
 r := gin.Default()
 group := r.Group("/api/asong",VerifyHeader())
 {
  group.GET("/ping", func(context *gin.Context) {
   context.JSON(200,gin.H{
    "message": "pong",
   })
  })
 }
 r.Run()
}


```

```
// HandlerFunc defines the handler used by gin middleware as return value.
type HandlerFunc func(*Context)

// HandlersChain defines a HandlerFunc array.
type HandlersChain []HandlerFunc

func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {
 finalSize := len(group.Handlers) + len(handlers)
 if finalSize >= int(abortIndex) {
  panic("too many handlers")
 }
 mergedHandlers := make(HandlersChain, finalSize)
 copy(mergedHandlers, group.Handlers)
 copy(mergedHandlers[len(group.Handlers):], handlers)
 return mergedHandlers
}


```

net/http 使用装饰器
--------------

```
type DecoratorHandler func(http.HandlerFunc) http.HandlerFunc

func MiddlewareHandlerFunc(hp http.HandlerFunc, decors ...DecoratorHandler) http.HandlerFunc {
 for d := range decors {
  dp := decors[len(decors)-1-d]
  hp = dp(hp)
 }
 return hp
}

func VerifyHeader(h http.HandlerFunc) http.HandlerFunc {
 return func(w http.ResponseWriter, r *http.Request) {
  token := r.Header.Get("token")
  if token == "" {
   fmt.Fprintf(w,r.URL.Path +" response: Not Logged in")
   return
  }
  h(w,r)
 }
}

func Pong(w http.ResponseWriter, r *http.Request)  {
 fmt.Fprintf(w,r.URL.Path +"response: pong")
 return
}


func main()  {
 http.HandleFunc("/api/asong/ping",MiddlewareHandlerFunc(Pong,VerifyHeader))
 err := http.ListenAndServe(":8080", nil)
 if err != nil {
  log.Fatal("ListenAndServe: ", err)
 }
}


```

总结
--

好啦，本文到这里就结束了，这一文我们学习了闭包的概念，通过闭包我们学习了如何在`Go`语言中使用装饰器，因为`Go`语言中不支持注解这个语法糖，所以使用装饰器还是有点丑陋的，不过这个思想还是挺重要的，我们日常开发中可以参考这种思想，写出更优质的代码来！