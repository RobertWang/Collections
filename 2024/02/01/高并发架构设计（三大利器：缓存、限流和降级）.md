> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653562681&idx=1&sn=652b379f26458e96f0669d5d3de10ef8&chksm=8139b6a1b64e3fb75548ed0564093d19bb8a3102b083ca73ef0eb0105e1c51f81284b319b62c&mpshare=1&scene=1&srcid=0201Ueyhq2PMxDrFhj6cFu71&sharer_shareinfo=f4952b8433158ad63d238e7a018eed94&sharer_shareinfo_first=f4952b8433158ad63d238e7a018eed94#rd)

软件系统有三个追求：**高性能、高并发、高可用**，俗称三高。三者既有区别也有联系，门门道道很多，全面讨论需要三天三夜，本篇讨论高并发。

**高并发对系统的挑战**

性能下降、资源竞争和稳定性问题等。

什么是高并发

**高并发的定义**

高并发是指系统或应用程序在同一时间段内接收到大量并发请求的能力。具体来说，高并发环境下系统需要能够同时处理大量的请求，而不会出现性能问题或响应延迟

**高并发的特点**

1. 大量请求：高并发场景下，系统需要同时处理大量的请求，这些请求可能来自于不同的用户或客户端。

2. 同时访问：这些请求几乎同时到达系统，需要在短时间内进行处理和响应。

3. 资源竞争：由于大量请求同时到达，系统的资源（如 CPU、内存、网络带宽等）可能会面临竞争和争夺。

4. 响应时间要求高：高并发场景通常对系统的响应速度有较高的要求，用户期望能够快速获取响应结果。

**高并发场景和应用**

高并发场景广泛应用于热门网站、电商平台、社交媒体等互联网应用中。例如，在电商平台上有大量用户同时浏览、搜索商品，提交订单等操作；社交媒体平台上有大量用户同时发布、点赞、评论等操作。这些场景需要系统能够同时处理大量请求，并保证系统的性能、可用性和用户体验。

**高并发的影响**

*   系统性能的下降和延迟增加
    
*   资源竞争和资源耗尽
    
*   系统稳定性和可用性的挑战
    

高并发应对策略

*   缓存：缓解系统负载压力，提高系统响应速度
    
*   限流：控制并发访问量，保护系统免受过载影响
    
*   降级：保证核心功能的稳定性，舍弃非关键业务或简化处理
    

缓存

**简介**

在网站或 APP 的开发中，缓存机制是一个不可或缺的环节，可以提高网站或 APP 的访问速度，降低数据库压力。在高并发环境下，缓存机制的作用更加明显，不仅可以有效减轻数据库的负载，还可以提高系统的稳定性和性能，从而给用户带来更好的体验。

**工作原理**

缓存的工作原理是先从缓存中获取数据，如果有数据则直接返回给用户，如果没有数据则从慢速设备上读取实际数据并且将数据放入缓存。

**常用技术**

### 浏览器缓存

#### **简介**

浏览器缓存是指将网页中的资源（如 HTML、CSS、JavaScript、图像等）存储在用户的浏览器内部，以便在后续请求同一资源时可以直接从本地缓存中获取，而无需再次从服务器下载。

#### **适用场景**

浏览器缓存适用于那些静态内容变化较少的网页和静态资源，可以显著提升网站性能和用户体验，并减少服务器的负载。

#### **常见用法**

使用浏览器缓存可以通过设置响应头中的 Expires 和 Cache-Control 字段来控制缓存的行为。

1. 使用 Expires 字段：Expires 字段指定了缓存的过期时间，是一个具体的日期和时间。服务器可以在响应头中添加 Expires 字段，告诉浏览器在该时间之前可以直接从缓存中获取资源，而无需再向服务器发起请求。例如：Expires: Mon, 31 Dec 2022 23:59:59 GMT。

2. 使用 Cache-Control 字段：Cache-Control 字段提供了更灵活的缓存控制选项。可以通过设置 max-age 指令来指定缓存的最大有效时间，单位是秒。例如：Cache-Control: max-age=3600 表示资源可以在 1 小时内直接从缓存中获取。还可以使用其他指令，如 no-cache 表示缓存但不使用缓存、no-store 表示禁止缓存等。

#### **注意事项**

浏览器缓存存储实时性不敏感的数据，如商品框架、商家评分、评价和广告词。它有过期时间，并通过响应头进行控制。实时性要求高的数据不适合使用浏览器缓存。

### 客户端缓存

#### **简介**

客户端缓存是将数据存储在浏览器中，以提高访问速度和减少服务器请求。

#### **适用场景**

在大促期间，为了防止服务端承受瞬间的高流量压力，可以提前将一些素材（如 js/css/image 等）下发到客户端进行缓存，避免在大促期间再次请求这些素材。此外，还可以将一些兜底数据或样式文件存放在客户端缓存中，以确保在服务端异常或网络异常的情况下，保持 app 的正常运行。

### CDN 缓存

#### **简介**

CDN 缓存通常用于存放静态页面数据、活动页面、图片等数据。它有两种缓存机制：推送机制（将数据主动推送到 CDN 节点）和拉取机制（首次访问时从源服务器获取数据并存储在 CDN 节点）。

#### **适用场景**

#### **常用工具以及用法**

### 反向代理缓存

#### **简介**

#### **适用场景**

#### **常用工具以及用法**

2.**Varnish：**一个专门用于反向代理缓存的开源软件，可以高效地缓存并提供快速的响应。

3.**Squid：**一款功能强大的缓存代理服务器，支持反向代理缓存和正向代理缓存。

### 本地缓存

#### **简介**

本地缓存是将数据或资源存储在客户端的存储介质中，如硬盘、内存或数据库。它可以是临时的，只在应用程序运行期间有效，或者可以是持久的，即在不同的应用程序会话中保持有效。

#### **适用场景**

本地缓存适用于**频繁访问数据**、离线访问、减少带宽消耗和提升用户体验的场景。

#### **常用工具以及用法**

**一般分为磁盘缓存、CPU 缓存、应用缓存**

1. 磁盘缓存：存储在硬盘等永久性存储介质上，用于加速数据的读取和访问。

3. 应用缓存：存储在内存中的应用程序数据或资源，用于提高应用程序的响应速度和用户体验。用 Java 服务来举例，又分为 堆内缓存 与 堆外缓存 。

### 分布式缓存

#### **简介**

#### **适用场景**

#### **常用工具以及用法**

### 缓存穿透

关键词：**强调缓存和数据库都没有数据 + 并发访问** 

缓存穿透是指数据库和缓存都没有的数据，每次都要经过缓存去访问数据库，大量的请求有可能导致 DB 宕机。

#### **应对策略**

1. 使用布隆过滤器（Bloom Filter）：布隆过滤器是一种快速判断元素是否存在的数据结构，它可以在很小的内存占用下，快速判断一个元素是否在一个集合中。将所有可能存在的数据哈希到一个足够大的位数组中，当一个请求过来时，先经过布隆过滤器判断是否存在于缓存中，如果不存在，则直接返回，避免对数据库的查询压力。

2. 空对象缓存：对于确定不存在的数据，在缓存中也存储一个空对象，表示该数据不存在。当请求访问这些不存在的数据时，直接从缓存中返回空对象，避免每次请求都穿透到数据库层进行查询。

3. 延迟双判：当一个查询请求穿透缓存到达数据库层后，先在数据库中进行查询，如果数据库也没有对应的数据，则将这个空结果写入缓存，并设置一个较短的过期时间。这样，下次相同的查询请求就会从缓存中得到空结果，而不会再次穿透到数据库。

4. 热点数据预加载：对于一些热点数据，在系统启动时或者在缓存过期前提前异步加载到缓存中，确保缓存的热点数据一直存在，避免被频繁请求的数据因为缓存过期而导致穿透问题。

5. 限流策略：针对频繁请求的特定数据，可以设置限流策略，例如使用令牌桶算法或漏桶算法，限制对这些数据的请求频率，减轻数据库的压力。

### 缓存击穿

关键词：**强调单个热点 Key 过期 + 并发访问**

缓存击穿是指数据库有，缓存没有的热点数据，大量请求访问这个缓存不存在的数据，最后请求打到 DB 可能导致 DB 宕机。

#### **应对策略**

1. 设置热点数据的热度时间窗口：对于热点数据，可以设置一个热度时间窗口，在这个时间窗口内，如果一个数据被频繁访问，就将其缓存时间延长，避免频繁刷新缓存导致缓存击穿。

2. 使用互斥锁或分布式锁：在缓存失效时，只允许一个线程去查询数据库，其他线程等待查询结果。可以使用互斥锁或分布式锁来实现，确保只有一个线程能够查询数据库，其他线程等待结果，避免多个线程同时查询数据库造成数据库压力过大。

3. 缓存永不过期：对于一些热点数据，可以将其缓存设置为永不过期，或者设置一个很长的过期时间，这样即使缓存失效，也有足够的时间来刷新缓存，避免缓存击穿。

4. 异步更新缓存：在缓存失效时，可以异步地去更新缓存，而不是同步地去查询数据库并刷新缓存。这样可以减少对数据库的直接访问，并且不会阻塞其他请求的响应。

5. 多级缓存架构：使用多级缓存架构，将热点数据分散到多个缓存节点上，避免单一缓存节点发生故障导致整个缓存层崩溃。当某个缓存节点失效时，可以从其他缓存节点或数据库中获取数据。

6. 熔断机制：当缓存层发生故障或无法正常工作时，可以设置熔断机制，直接访问数据库，保证系统的正常运行。

### 缓存雪崩

关键词：**强调批量 Key 过期 + 并发访问** 

缓存雪崩指的是在同一时段大量的缓存键（key）同时失效，导致大量请求打到数据库，最后请求打到 DB 可能导致 DB 宕机。

#### **应对策略**

1. 使用多级缓存架构：将缓存划分为多个层级，每个层级的缓存设置不同的过期时间。例如，将热点数据存储在近期失效的缓存层级，而将非热点数据存储在长期失效的缓存层级。这样即使某一层级的缓存失效，仍然可以从其他层级获取数据，避免所有请求直接访问数据库。

2. 设置缓存数据的随机过期时间：在设置缓存数据的过期时间时，加上一个随机值，使得不同的缓存数据在过期时刻不一致。这样可以避免大量数据同时过期，减轻数据库负荷。

3. 分布式锁或互斥锁：在缓存失效时，使用分布式锁或互斥锁来保证只有一个请求可以重新加载缓存。其他请求等待该请求完成后，直接从缓存中获取数据。这样可以避免多个请求同时访问数据库。

4. 数据预热：在系统启动或者非高峰期，提前将热点数据加载到缓存中，预热缓存。这样即使在高并发时，也能够从缓存中获取到数据，减轻数据库的压力。

5. 缓存限流：当检测到缓存失效时，可以对请求进行限流处理，限制并发请求的数量。这样可以避免大量请求同时访问数据库，导致数据库负载过大。

6. 数据库优化：对于缓存雪崩问题，除了缓存层面的应对策略，还可以从数据库层面进行优化，如提升数据库性能、增加数据库的容量等，以应对大量请求导致的数据库压力。

### 缓存一致性

缓存一致性指的是缓存与 DB 之间的数据一致性，我们需要通过各种手段来防止缓存与 DB 不一致，我们要保证缓存与 DB 的数据一致或者数据最终一致。

#### **应对策略**

针对缓存一致性问题，可以从不同的层次来应对：

1. 数据库层：

*   在数据库层面，可以使用事务来确保数据的一致性。通过将读写操作放在同一个事务中，可以保证数据的更新和查询是一致的。
    
*   使用数据库的**触发器**或者存储过程，在数据更新的同时，主动触发缓存的更新操作，确保缓存与数据库的数据保持一致。
    

2. 缓存层：

*   在缓存层面，可以使用缓存更新策略，通过定时任务、异步消息队列等方式，定期或者在数据更新时异步地更新缓存，保持缓存与数据库的数据一致性。
    
*   使用互斥锁或者分布式锁来保证对缓存的读写操作的原子性，避免数据冲突。
    
*   设置**合适的缓存过期时间**，避免缓存数据长时间过期而导致数据不一致的问题。
    

3. 应用层：

*   在应用层面，可以采用读写分离策略，将读请求和写请求分发到不同的节点，读请求直接从缓存中获取数据，写请求则更新数据库并更新缓存，保持数据的一致性。
    
*   使用缓存中间件或者缓存组件，提供自动更新缓存的功能，减少手动维护缓存的复杂性。
    

4. 监控和报警：

*   建立监控和报警机制，通过监控缓存层和数据库层的状态、数据一致性等指标，及时发现异常情况，并触发报警，以便及时处理问题。
    

综合使用以上层次的策略，可以有效地应对缓存一致性问题，保证数据的一致性和系统的稳定性。不同层次的策略可以相互配合，形成一个完善的缓存一致性解决方案。

### 其他

缓存的好处我们非常受益，用户的每一次请求都伴随着无数缓存的诞生，但是缓存同时也给我们带来了不小的挑战，比如在上面提到的一些疑难课题：缓存穿透、缓存击穿、缓存雪崩和缓存一致性。

除此之外，我们还会涉及到其他的一些缓存难题，如：缓存倾斜、缓存阻塞、缓存慢查询、缓存主从一致性问题、缓存高可用、缓存故障发现与故障恢复、集群扩容收缩、大 Key 热 Key......

### 小结

<table width="768"><colgroup><col width="108"><col width="108"><col width="166"><col width="107"><col width="143"><col width="146"></colgroup><tbody><tr data-cangjie-key="424" data-sticky="false"><td data-cangjie-key="426" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>缓存类型</section></td><td data-cangjie-key="431" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>介绍</section></td><td data-cangjie-key="436" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>解决方案 / 工具</section></td><td data-cangjie-key="441" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>优点</section></td><td data-cangjie-key="446" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>缺点</section></td><td data-cangjie-key="451" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>适用场景</section></td></tr><tr data-cangjie-key="456" data-sticky="false"><td data-cangjie-key="458" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>浏览器缓存</section></td><td data-cangjie-key="463" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>存储在用户设备上的缓存，用于存储静态资源和页面内容。</section></td><td data-cangjie-key="468" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" class=""><section>通过设置 HTTP 头中的缓存相关字段来控制缓存行为。</section></td><td data-cangjie-key="473" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 快速响应，避免频繁访问服务器或网络</section><section>- 减少网络带宽消耗，提升网站性能</section></td><td data-cangjie-key="481" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计</section><section>- 缓存命中率受限于缓存容量和缓存策略的选择</section></td><td data-cangjie-key="489" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 静态资源的缓存 - 减少网络带宽消耗</section></td></tr><tr data-cangjie-key="494" data-sticky="false"><td data-cangjie-key="496" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>客户端缓存</section></td><td data-cangjie-key="501" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>应用程序在用户设备上的缓存，用于存储数据、计算结果或其他业务相关的内容。</section></td><td data-cangjie-key="506" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>使用本地存储、SessionStorage、LocalStorage 或 IndexedDB 等 Web API 来进行数据的存储和读取。</section></td><td data-cangjie-key="511" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 减轻后端负载，提升系统性能</section><section>- 快速响应，避免频繁访问服务器或网络资源</section></td><td data-cangjie-key="519" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 缓存数据可能不是最新的，需要考虑缓存一致性和更新机制的设计</section><section>- 缓存命中率受限于缓存容量和缓存策略的选择</section></td><td data-cangjie-key="527" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 频繁访问的数据或计算结果 - 减轻后端负载</section></td></tr><tr data-cangjie-key="532" data-sticky="false"><td data-cangjie-key="534" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>CDN 缓存</section></td><td data-cangjie-key="539" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>内容分发网络的缓存，用于存储和加速静态资源的分发。</section></td><td data-cangjie-key="544" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>部署静态资源到 CDN 服务器并配置 CDN 缓存策略，用户请求将被转发到就近的 CDN 节点，加速内容的分发和访问。</section></td><td data-cangjie-key="549" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 加速静态资源的访问速度，提升用户体验</section><section>- 减轻源服务器负载，提高系统可扩展性</section></td><td data-cangjie-key="557" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 只适用于静态资源的缓存，动态内容无法缓存</section><section>- CDN 配置和管理的复杂性</section></td><td data-cangjie-key="565" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 静态资源的分发和访问 - 加速静态资源的加载和访问</section></td></tr><tr data-cangjie-key="570" data-sticky="false"><td data-cangjie-key="572" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>反向代理缓存</section></td><td data-cangjie-key="577" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>位于服务器前端的缓存，用于缓存和加速动态内容和静态资源的访问。</section></td><td data-cangjie-key="582" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>配置反向代理服务器并设置缓存策略，将用户请求转发到缓存服务器，减轻后端服务器的负载并加速内容的访问。</section></td><td data-cangjie-key="587" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 加速内容的访问速度，提升用户体验</section><section>- 减轻源服务器负载，提高系统可扩展性</section></td><td data-cangjie-key="595" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 只适用于特定的 Web 服务器和应用程序</section></td><td data-cangjie-key="600" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 动态内容和静态资源的缓存和加速访问 - 减轻后端服务器的负载</section></td></tr><tr data-cangjie-key="605" data-sticky="false"><td data-cangjie-key="607" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>本地缓存</section></td><td data-cangjie-key="612" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>应用程序在用户设备上的缓存，用于缓存数据和资源以提高应用的性能和响应速度。</section></td><td data-cangjie-key="617" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" class=""><section>使用缓存库或框架（如 localStorage、sessionStorage、Workbox 等）来实现本地缓存功能。</section></td><td data-cangjie-key="622" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 提升应用的性能和响应速度</section><section>- 减少对远程资源的依赖，提高离线使用体验</section></td><td data-cangjie-key="630" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 本地缓存容量受限于用户设备的存储空间</section></td><td data-cangjie-key="635" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 频繁访问的数据或资源 - 提升应用的性能和响应速度</section></td></tr><tr data-cangjie-key="640" data-sticky="false"><td data-cangjie-key="642" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>分布式缓存</section></td><td data-cangjie-key="647" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>在分布式系统中使用的缓存，用于存储和共享数据。分布式缓存通常部署在多台服务器上，并提供高并发读写能力和数据访问的可扩展性。分布式缓存常用于大规模应用和系统中。</section></td><td data-cangjie-key="652" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>使用分布式缓存系统（如 Redis、Memcached 等）来存储和访问缓存数据。</section></td><td data-cangjie-key="657" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 高并发读写能力和数据存储的可扩展性</section></td><td data-cangjie-key="662" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 需要额外的服务器资源来部署和管理分布式缓存系统</section><section>- 缓存一致性和数据同步问题需要考虑</section></td><td data-cangjie-key="670" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true"><section>- 高并发读写能力和数据存储的可扩展性 - 大规模应用和系统的缓存和数据共享</section></td></tr></tbody></table>

以上是对浏览器缓存、客户端缓存、CDN 缓存、反向代理缓存、本地缓存和分布式缓存的横向对比，包括介绍、解决方案 / 工具、优点和缺点以及适用场景的详细信息。根据具体需求和系统架构，选择适合的缓存类型和方案，以提高系统性能、减轻服务器负载、改善用户体验和保证数据一致性。

限流

**简介**

再强大的系统，也怕流量短事件内集中爆发，就像银行怕挤兑一样，所以，高并发另一个必不可少的模块就是限流。

限流是一种通过控制请求的速率或数量来保护系统免受过载的技术。流控的精髓是限制单位时间内的请求量，最大程度保障系统的可靠性及可用性。

**作用**

限流是在高并发环境下，为了保护系统的稳定性和可用性而引入的一种策略。通过限制并发请求的数量或频率，可以防止系统被过多的请求压垮或耗尽资源。

**限流算法**

常见的流控算法包括：固定窗口、滑动窗口、漏桶、令牌桶、滑动日志等算法。

#### 固定窗口算法（计数器）

##### **简介**

固定窗口限流算法（Fixed Window Rate Limiting Algorithm）是一种最简单的限流算法，其原理是在固定时间窗口 (单位时间) 内限制请求的数量。

##### **原理**

固定窗口是最简单的流控算法。即，给定**时间窗口**，维护一个**计数器**用于统计访问次数，并实现以下规则：

1. 如果访问次数小于阈值，则允许访问，访问次数 + 1；

2. 如果访问次数超出阈值，则限制访问，访问次数不增；

3. 如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。

##### **适用场景**

*   保护后端服务免受大流量冲击，避免服务崩溃；
    
*   对 API 调用进行限制，保证公平使用；
    
*   防止恶意用户对服务进行洪水攻击；
    

##### **实现方式**

```
public class FixedWindowRateLimiter {
    private static int counter = 0;  // 统计请求数
    private static long lastAcquireTime = 0L;
    private static final long windowUnit = 1000L; // 假设固定时间窗口是1000ms
    private static final int threshold = 10; // 窗口阀值是10
    public synchronized boolean tryAcquire() {
        long currentTime = System.currentTimeMillis();  // 获取系统当前时间
        if (currentTime - lastAcquireTime > windowUnit) {  // 检查是否在时间窗口内
            counter = 0;  // 计数器清零
            lastAcquireTime = currentTime;  // 开启新的时间窗口
        }
        if (counter < threshold) {  // 小于阀值
            counter++;  // 计数器加1
            return true;  // 获取请求成功
        }
        return false;  // 超过阀值，无法获取请求
    }
}

```

代码说明：

使用了一个静态的 counter 变量来记录请求数量，lastAcquireTime 变量记录上一次获取请求的时间戳。windowUnit 表示固定时间窗口的长度，threshold 则表示在时间窗口内的请求数阀值。

tryAcquire() 方法使用了 synchronized 关键字来实现线程安全，在方法中进行以下操作：

1. 获取当前系统时间 currentTime。

2. 检查当前时间是否距离上一次获取请求的时间超过了时间窗口长度 windowUnit。如果超过了时间窗口，则将计数器 counter 清零，并更新 lastAcquireTime 为当前时间，表示进入新的时间窗口。

3. 如果计数器 counter 小于阀值 threshold，则将计数器加 1，并返回 true 表示获取请求成功。

4. 如果计数器已经达到或超过阀值，则返回 false 表示无法获取请求。﻿

##### **优劣分析**

*   优点
    

*   固定窗口算法非常简单，易于实现和理解。
    
*   **性能高**
    

*   缺点
    

*   存在明显的临界问题
    
    eg:
    
    比如: 假设限流阀值为 5 个请求，单位时间窗口是 1s，如果我们在单位时间内的**前 0.8-1s** 和 **1-1.2s**，分别并发 5 个请求。虽然都没有超过阀值，但是如果算 **0.8-1.2s** 内的，则并发数高达 10，已经超过单位时间 1s 不超过 5 阀值的定义了。
    

﻿﻿滑动窗口算法

##### **简介**

为了解决临界突变问题，可以引入滑动窗口。即：把大的时间窗口拆分成若干**粒度更细**的子窗口，每个子窗口独立统计，**按子窗口时间滑动**，统一限流。

当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

##### **原理**

将单位时间周期分为 **n 个小周期**，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。它可以解决固定窗口临界值的问题。

![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJlRgK6EYMp8u2TxYwwJfGgVxCMW8BgT23lvncLMJZHaX3GSllauqbPkicCaGG2AmJpXBQ0LfZ0Fsw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)﻿﻿

假设单位时间还是 **1s**，滑动窗口算法把它划分为 **5 个小周期**，也就是滑动窗口（单位时间）被划分为 **5 个小格子**。每格表示 **0.2s**。每过 **0.2s**，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是 **0.83s** 到达的，**0.8~1.0s** 对应的计数器就会**加 1**。

假设我们 1s 内的限流阀值还是 5 个请求，0.8~1.0s 内（比如 0.9s 的时候）来了 5 个请求，落在黄色格子里。﻿

时间过了 1.0s 这个点之后，又来 5 个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了 1.0s 这个点后，会右移一小格，当前的单位时间段是 0.2~1.2s，这个区域的请求已经超过限定的 5 了，已触发限流啦，实际上，紫色格子的请求都被拒绝。

##### **实现方式**

```
import java.util.LinkedList;
import java.util.Queue;
public class SlidingWindowRateLimiter {
    private Queue<Long> timestamps; // 存储请求的时间戳队列
    private int windowSize; // 窗口大小，即时间窗口内允许的请求数量
    private long windowDuration; // 窗口持续时间，单位：毫秒
    public SlidingWindowRateLimiter(int windowSize, long windowDuration) {
        this.windowSize = windowSize;
        this.windowDuration = windowDuration;
        this.timestamps = new LinkedList<>();
    }
    public synchronized boolean tryAcquire() {
        long currentTime = System.currentTimeMillis(); // 获取当前时间戳
        // 删除超过窗口持续时间的时间戳
        while (!timestamps.isEmpty() && currentTime - timestamps.peek() > windowDuration) {
            timestamps.poll();
        }
        if (timestamps.size() < windowSize) { // 判断当前窗口内请求数是否小于窗口大小
            timestamps.offer(currentTime); // 将当前时间戳加入队列
            return true; // 获取请求成功
        }
        return false; // 超过窗口大小，无法获取请求
    }
}

```

**代码解读**

在以上代码中，使用了一个 Queue（队列）来存储请求的时间戳。构造函数中传入窗口大小 windowSize 和窗口持续时间 windowDuration。

tryAcquire() 方法使用了 synchronized 关键字来实现线程安全，在方法中进行以下操作：

1. 获取当前系统时间戳 currentTime。

2. 从队列中删除超过窗口持续时间的时间戳，确保队列中只保留窗口内的时间戳。

3. 判断当前窗口内请求数是否小于窗口大小 windowSize。

*   如果小于窗口大小，将当前时间戳加入队列，并返回 true 表示获取请求成功。
    
*   如果已经达到或超过窗口大小，表示请求数已满，返回 false 表示无法获取请求。
    

使用这个滑动窗口限流算法，可以限制在一定时间窗口内的请求频率，超过窗口大小的请求会被限制。您可以根据实际需求和业务场景进行调整和使用。﻿

##### **适用场景**

同固定窗口的场景，且对流量限制要求较高的场景，**需要更好地应对突发流量**。

##### **优劣分析**

*   优势
    

*   简单易懂
    
*   精度高（通过调整时间窗口的大小来实现不同的限流效果）
    
*   可扩展性强（可以非常容易地与其他限流算法结合使用）
    

*   劣质
    
    突发流量无法处理（无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。这样我们会损失一部分请求，这其实对于产品来说，并不太友好），需要合理调整时间窗口大小。
    

#### 漏桶算法

##### **简介**

**基于（出口）流速来做流控。**在网络通信中常用于流量整形，可以很好地解决平滑度问题。

##### **特点**

*   可以以任意速率流入水滴到漏桶（流入请求）
    
*   漏桶具有固定容量，出水速率是固定常量（流出请求）
    
*   如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）
    

##### **原理**

*   思想
    

将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量

*   工作原理
    

对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。如果超过了容量，就将多余的数据包丢弃。如果漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流的目的。

##### **代码实现**

```
public class LeakyBucketRateLimiter {
    private long capacity; // 漏桶容量，即最大允许的请求数量
    private long rate; // 漏水速率，即每秒允许通过的请求数量
    private long water; // 漏桶当前水量
    private long lastTime; // 上一次请求通过的时间戳
    public LeakyBucketRateLimiter(long capacity, long rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.water = 0;
        this.lastTime = System.currentTimeMillis();
    }
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long elapsedTime = now - lastTime;
        // 计算漏桶中的水量
        water = Math.max(0, water - elapsedTime * rate / 1000);
        if (water < capacity) { // 判断漏桶中的水量是否小于容量
            water++; // 漏桶中的水量加1
            lastTime = now; // 更新上一次请求通过的时间戳
            return true; // 获取请求成功
        }
        return false; // 漏桶已满，无法获取请求
    }
}

```

**代码解读**

在以上代码中，capacity 表示漏桶的容量，即最大允许的请求数量；rate 表示漏水速率，即每秒允许通过的请求数量。water 表示漏桶中当前的水量，lastTime 表示上一次请求通过的时间戳。

tryAcquire() 方法使用了 synchronized 关键字来实现线程安全，在方法中进行以下操作：

1. 获取当前系统时间戳 now。

2. 计算从上一次请求通过到当前的时间间隔 elapsedTime。

3. 根据漏水速率和时间间隔，计算漏桶中的水量。

4. 判断漏桶中的水量是否小于容量。

*   如果小于容量，漏桶中的水量加 1，更新上一次请求通过的时间戳，并返回 true 表示获取请求成功。
    
*   如果已经达到或超过容量，漏桶已满，返回 false 表示无法获取请求。﻿
    

##### **适用场景**

一般用于保护第三方的系统，比如自身的系统需要调用第三方的接口，为了保护第三方的系统不被自身的调用打垮，便可以通过漏斗算法进行限流，保证自身的流量平稳的打到第三方的接口上。

##### **优劣分析**

*   优势
    

*   可以平滑限制请求的处理速度，避免瞬间请求过多导致系统崩溃或者雪崩。
    
*   可以控制请求的处理速度，使得系统可以适应不同的流量需求，避免过载或者过度闲置。
    
*   可以通过调整桶的大小和漏出速率来满足不同的限流需求，可以灵活地适应不同的场景。
    

*   劣质
    

*   需要对请求进行缓存，会增加服务器的内存消耗。
    
*   对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。
    
*   但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。
    

#### 令牌桶算法

##### **简介**

基于（入口）流速来做流控的一种限流算法。

##### **原理**

该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。

![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJlRgK6EYMp8u2TxYwwJfGgHYEpNEIiaMPdnzsPBNtQJqM03MJHic0wuibD24YASIbb7w5b8edxbSmQA/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

##### **实现方式**

```
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class TokenBucketRateLimiter {
    private long capacity; // 令牌桶容量，即最大允许的请求数量
    private long rate; // 令牌产生速率，即每秒产生的令牌数量
    private long tokens; // 当前令牌数量
    private ScheduledExecutorService scheduler; // 调度器
    public TokenBucketRateLimiter(long capacity, long rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.tokens = capacity;
        this.scheduler = new ScheduledThreadPoolExecutor(1);
        scheduleRefill(); // 启动令牌补充任务
    }
    private void scheduleRefill() {
        scheduler.scheduleAtFixedRate(() -> {
            synchronized (this) {
                tokens = Math.min(capacity, tokens + rate); // 补充令牌，但不超过容量
            }
        }, 1, 1, TimeUnit.SECONDS); // 每秒产生一次令牌
    }
    public synchronized boolean tryAcquire() {
        if (tokens > 0) { // 判断令牌数量是否大于0
            tokens--; // 消耗一个令牌
            return true; // 获取请求成功
        }
        return false; // 令牌不足，无法获取请求
    }
}

```

**代码解读**

capacity 表示令牌桶的容量，即最大允许的请求数量；rate 表示令牌产生速率，即每秒产生的令牌数量。tokens 表示当前令牌数量，scheduler 是用于调度令牌补充任务的线程池。

在构造方法中，初始化令牌桶的容量和当前令牌数量，并启动令牌补充任务 scheduleRefill()。

scheduleRefill() 方法使用调度器定期执行令牌补充任务，每秒补充一次令牌。在补充任务中，通过加锁的方式更新令牌数量，确保线程安全。补充的令牌数量为当前令牌数量加上产生速率，但不超过令牌桶的容量。

tryAcquire() 方法使用 synchronized 关键字来实现线程安全，在方法中进行以下操作：

*   如果令牌数量大于 0，表示令牌足够，消耗一个令牌，并返回 true 表示获取请求成功。
    
*   如果令牌数量为 0，表示令牌不足，返回 false 表示无法获取请求。﻿
    

##### **适用场景**

##### **优劣分析**

*   优势
    

*   稳定性高：令牌桶算法可以控制请求的处理速度，可以使系统的负载变得稳定。
    
*   精度高：令牌桶算法可以根据实际情况动态调整生成令牌的速率，可以实现较高精度的限流。
    
*   弹性好：令牌桶算法可以处理突发流量，可以在短时间内提供更多的处理能力，以处理突发流量。
    

*   劣质
    

*   实现复杂：相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。对短时请求难以处理：在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。
    
*   时间精度要求高：令牌桶算法需要在固定的时间间隔内生成令牌，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。
    

#### 滑动日志算法（比较冷门）

##### **简介**

##### **原理**

2. 维护滑动窗口：使用一个滑动窗口来记录每个时间窗口内的请求次数。这个滑动窗口可以是一个固定长度的队列或数组。

3. 请求计数：当一个请求到达时，将其计数加一并放入当前时间窗口中。

4. 滑动：随着时间的流逝，滑动窗口会根据当前时间窗口的长度，移除最旧的请求计数，并将新的请求计数添加到最新的时间窗口中。

5. 限流判断：在每个时间窗口结束时，统计滑动窗口中的请求计数总和，并与预设的阈值进行比较。如果总请求数超过阈值，则触发限流处理。

6. 限流处理：一旦触发限流，可以采取不同的处理策略，如拒绝请求、延迟处理、返回错误信息等。具体的限流策略可以根据实际情况进行选择。

通过滑动日志算法进行限流，可以实现对单位时间内的请求进行精确控制。它基于实时统计的方式，能够动态地适应请求流量的变化，并且在内存使用上比较高效。同时，通过调整时间窗口的长度和阈值的设置，可以灵活地控制限流的精度和灵敏度。

##### **实现方式**

```
import java.util.LinkedList;
import java.util.List;
public class SlidingLogRateLimiter {
    private int requests; // 请求总数
    private List<Long> timestamps; // 存储请求的时间戳列表
    private long windowDuration; // 窗口持续时间，单位：毫秒
    private int threshold; // 窗口内的请求数阀值
    public SlidingLogRateLimiter(int threshold, long windowDuration) {
        this.requests = 0;
        this.timestamps = new LinkedList<>();
        this.windowDuration = windowDuration;
        this.threshold = threshold;
    }
    public synchronized boolean tryAcquire() {
        long currentTime = System.currentTimeMillis(); // 获取当前时间戳
        // 删除超过窗口持续时间的时间戳
        while (!timestamps.isEmpty() && currentTime - timestamps.get(0) > windowDuration) {
            timestamps.remove(0);
            requests--;
        }
        if (requests < threshold) { // 判断当前窗口内请求数是否小于阀值
            timestamps.add(currentTime); // 将当前时间戳添加到列表
            requests++; // 请求总数增加
            return true; // 获取请求成功
        }
        return false; // 超过阀值，无法获取请求
    }
}

```

代码解读：

在以上代码中，requests 表示请求总数，timestamps 用于存储请求的时间戳列表，windowDuration 表示窗口持续时间，threshold 表示窗口内的请求数阀值。

在构造函数中传入窗口内的请求数阀值和窗口持续时间。

tryAcquire() 方法使用了 synchronized 关键字来实现线程安全，在方法中进行以下操作：

1. 获取当前系统时间戳 currentTime。

2. 删除超过窗口持续时间的时间戳，同时更新请求总数。

3. 判断当前窗口内请求数是否小于阀值。

*   如果小于阀值，将当前时间戳添加到列表，请求总数增加，并返回 true 表示获取请求成功。
    
*   如果已经达到或超过阀值，表示请求数已满，返回 false 表示无法获取请求。
    

使用这个滑动日志限流算法，可以限制在一定时间窗口内的请求频率，超过阀值的请求会被限制。您可以根据实际需求和业务场景进行调整和使用。

##### **适用场景**

对**实时性要求高**，且需要精确控制请求速率的高级限流场景。

##### **优劣分析**

*   优势
    

*   滑动日志能够避免突发流量，实现较为精准的限流；
    
*   更加灵活，能够支持更加复杂的限流策略 如多级限流，每分钟不超过 100 次，每小时不超过 300 次，每天不超过 1000 次，我们只需要保存最近 24 小时所有的请求日志即可实现。
    

*   劣质
    

*   占用存储空间要高于其他限流算法。
    

#### 几种算法小结

<table width="768"><colgroup><col width="92"><col width="118"><col width="108"><col width="91"><col width="92"><col width="93"><col width="217"></colgroup><tbody><tr data-cangjie-key="1209" data-sticky="false"><td data-cangjie-key="1211" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>算法</p></td><td data-cangjie-key="1216" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>简介</p></td><td data-cangjie-key="1221" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>核心思想</p></td><td data-cangjie-key="1226" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>优点</p></td><td data-cangjie-key="1231" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>缺点</p></td><td data-cangjie-key="1236" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>开源工具 / 中间件</p></td><td data-cangjie-key="1241" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit; background-color: rgba(236, 236, 241, 0.2);"><p>适用业务场景</p></td></tr><tr data-cangjie-key="1246" data-sticky="false"><td data-cangjie-key="1248" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>固定窗口限流</p></td><td data-cangjie-key="1253" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>在固定的时间窗口内计数请求，达到阈值则限流。</p></td><td data-cangjie-key="1258" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>将时间分割成固定大小的窗口，每个窗口内独立计数。</p></td><td data-cangjie-key="1263" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>实现简单，性能较好。</p></td><td data-cangjie-key="1268" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>可能会有时间窗口切换时的突发流量。</p></td><td data-cangjie-key="1273" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>Nginx、Apache、RateLimiter (Guava)</p></td><td data-cangjie-key="1278" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>需要简单限流，对流量突增不敏感的场景。</p><p>eg:</p><p>电商平台在每日定时秒杀活动开始时，用于防止瞬时高流量冲垮系统。</p></td></tr><tr data-cangjie-key="1289" data-sticky="false"><td data-cangjie-key="1291" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>滑动窗口限流</p></td><td data-cangjie-key="1296" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;" class=""><p>在滑动的时间窗口内计数请求，达到阈值则限流。</p></td><td data-cangjie-key="1301" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>将时间分割为多个小窗口，统计近期内的总请求数。</p></td><td data-cangjie-key="1306" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>平滑请求，避免固定窗口算法中的突发流量。</p></td><td data-cangjie-key="1311" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>实现比固定窗口复杂，消耗资源较多。</p></td><td data-cangjie-key="1316" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>Redis、Sentinel</p></td><td data-cangjie-key="1321" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>对流量平滑性有较高要求的场景。</p><p>eg:</p><p>社交媒体平台的消息发送功能，用于平滑处理高峰期的消息发送请求，避免服务短暂的超负荷。</p></td></tr><tr data-cangjie-key="1335" data-sticky="false"><td data-cangjie-key="1337" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>令牌桶限流</p></td><td data-cangjie-key="1342" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>以恒定速率向桶中添加令牌，请求消耗令牌，无令牌时限流。</p></td><td data-cangjie-key="1347" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>以一定速率生成令牌，请求必须拥有令牌才能执行。</p></td><td data-cangjie-key="1352" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>允许一定程度的突发流量，平滑处理请求。</p></td><td data-cangjie-key="1357" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>对突发流量的容忍可能导致短时间内资源过载。</p></td><td data-cangjie-key="1362" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>Guava、Nginx、Apache、</p><p>Sentinel</p></td><td data-cangjie-key="1370" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>对突发流量有一定要求，且需要一定程度的平滑处理的场景。</p><p>eg:</p><p>视频流媒体服务，允许用户在网络状况良好时快速缓冲视频，同时在网络拥堵时平滑地降低请求速率。</p></td></tr><tr data-cangjie-key="1384" data-sticky="false"><td data-cangjie-key="1386" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>漏桶算法</p></td><td data-cangjie-key="1391" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>漏桶以固定速率出水，请求以任意速率流入桶内，桶满则溢出（限流）。</p></td><td data-cangjie-key="1396" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>以恒定的速率处理请求，超过该速率的请求被限制。</p></td><td data-cangjie-key="1401" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>输出流量稳定，能够限制流量的最大速率。</p></td><td data-cangjie-key="1406" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>无法应对突发流量，可能导致请求等待时间过长。</p></td><td data-cangjie-key="1411" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>Apache、Nginx</p></td><td data-cangjie-key="1416" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-bottom-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>适用于需要严格控制处理速率，对请求响应时间要求不高的场景。</p><p>eg:</p><p>API 网关对外提供服务的接口，需要确保后端服务的调用速率不超过其最大处理能力，防止服务崩溃</p></td></tr><tr data-cangjie-key="1430" data-sticky="false"><td data-cangjie-key="1432" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>滑动日志限流</p></td><td data-cangjie-key="1437" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>使用滑动时间窗口记录请求日志，通过日志来判断是否超出速率限制。</p></td><td data-cangjie-key="1442" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>记录最近一段时间内的请求日志，实时判断请求是否超限。</p></td><td data-cangjie-key="1447" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>能够更细粒度地控制请求速率，比固定窗口更公平。</p></td><td data-cangjie-key="1452" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>实现复杂，存储和计算请求日志成本较高。</p></td><td data-cangjie-key="1457" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>-</p></td><td data-cangjie-key="1462" data-type="table-cell" rowspan="1" colspan="1" data-container-block="true" data-style="padding: 8px 7px; outline: 0px; word-break: break-all; hyphens: auto; border-top-width: 0px; border-color: rgb(217, 217, 227); box-sizing: inherit;"><p>对实时性要求高，且需要精确控制请求速率的高级限流场景。</p><p>eg：</p><p>高频交易系统，需要根据实时交易数据精确控制交易请求速率，防止因超负荷而影响整体市场的稳定性。</p></td></tr></tbody></table>

**常用工具**

### RateLimiter（单机）

#### **简介**

基于**令牌桶算法**实现的一个多线程限流器，它可以将请求均匀的进行处理，当然他并不是一个分布式限流器，只是对单机进行限流。它可以应用在定时拉取接口数。通过 aop、filter、Interceptor 等都可以达到限流效果。

#### **用法**

以下是一个基本的 RateLimiter 用法示例：

```
import com.google.common.util.concurrent.RateLimiter;
public class RateLimiterDemo {
    public static void main(String[] args) {
        // 创建一个每秒允许2个请求的RateLimiter
        RateLimiter rateLimiter = RateLimiter.create(2.0);
        while (true) {
            // 请求RateLimiter一个令牌
            rateLimiter.acquire();
            // 执行操作
            doSomeLimitedOperation();
        }
    }
    private static void doSomeLimitedOperation() {
        // 模拟一些操作
        System.out.println("Operation executed at: " + System.currentTimeMillis());
    }
}

```

在这个例子中，RateLimiter.create(2.0) 创建了一个每秒钟只允许 2 个操作的限速器。rateLimiter.acquire() 方法会阻塞当前线程直到获取到许可，确保调用 doSomeLimitedOperation() 操作的频率不会超过限制。

RateLimiter 还提供了其他的方法，例如 tryAcquire()，它会尝试获取许可而不会阻塞，立即返回获取成功或失败的结果。还可以设置等待时间上限，比如 tryAcquire(long timeout, TimeUnit unit) 可以设置最大等待时间。

Guava 的 RateLimiter 非常灵活，它支持平滑突发限制（SmoothBursty）和平滑预热限制（SmoothWarmingUp）等多种模式，可以根据特定的应用场景来选择合适的限流策略。

### sentinel（单机或者分布式）

#### **简介**

Sentinel 是阿里巴巴开源的一款面向分布式系统的流量控制和熔断降级组件。它提供了实时的流量控制、熔断降级、系统负载保护和实时监控等功能，可以帮助开发者保护系统的稳定性和可靠性。

##### **单机模式**

![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJlRgK6EYMp8u2TxYwwJfGg5icc0hibYybJbXGB6ic9WCm8I1bMJNDNWkjibLUApoISPZ4e6uvUsdr1rA/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

*   DefaultController：是一个非常典型的**滑动窗口计数器**算法实现，将当前统计的 qps 和请求进来的 qps 进行求和，小于限流值则通过，大于则计算一个等待时间，稍后再试；
    
*   ThrottlingController：是**漏斗算法**的实现，实现思路已经在源码片段中加了备注；
    
*   WarmUpController：实现参考了 Guava 的带预热的 RateLimiter，区别是 Guava 侧重于请求间隔，类似前面提到的**令牌桶**，而 Sentinel 更关注于请求数，和令牌桶算法有点类似；
    
*   WarmUpRateLimiterController：低水位使用**预热算法**，高水位使用**滑动窗口计数器**算法排队。
    

##### **集群模式**

Sentinel 集群限流服务端有两种启动方式：

*   嵌入模式（Embedded）适合应用级别的限流，部署简单，但对应用性能有影响
    
*   独立模式（Alone）适合全局限流，需要独立部署
    

#### **用法**

Sentinel 的用法主要包括以下几个方面：

1. 引入依赖：在项目中引入 Sentinel 的相关依赖，可以使用 Maven 或 Gradle 进行依赖管理。例如，在 Maven 项目的 pom.xml 文件中添加以下依赖：

```
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-core</artifactId>
    <version>1.8.2</version>
</dependency>

```

2. 配置规则：根据实际需求，配置 Sentinel 的流量控制规则、熔断降级规则等。可以通过编程方式或配置文件方式进行规则的配置。例如，可以在启动类中使用注解方式配置流量控制规则：

```
@SentinelResource(value = "demo", blockHandler = "handleBlock")
public String demo() {
    // ...
}

```

3. 启动 Agent：在应用启动时，启动 Sentinel 的 Agent，开启对系统的流量控制和熔断降级功能的保护。可以通过命令行启动 Agent，或者在代码中进行启动。例如，在 Spring Boot 的启动类中添加如下代码：

```
public static void main(String[] args) {
    System.setProperty("csp.sentinel.dashboard.server", "localhost:8080"); // 设置控制台地址
    System.setProperty("project.name", "your-project-name"); // 设置应用名称
    com.alibaba.csp.sentinel.init.InitExecutor.doInit();
    SpringApplication.run(YourApplication.class, args);
}

```

4. 监控和管理：使用 Sentinel 的控制台进行实时监控、配置管理等操作。可以通过浏览器访问 Sentinel 的控制台界面，查看系统的运行情况和流量控制情况。通过控制台，可以对规则进行动态修改，查看监控数据和告警信息。

### Nginx（分布式）

#### **简介**

Nginx 从网关这一层面考虑，可以作为最前置的网关，抵挡大部分的网络流量，因此使用 Nginx 进行限流也是一个很好的选择，在 Nginx 中，也提供了常用的基于限流相关的策略配置。

#### **用法**

Nginx 提供了两种限流方法：一种是控制速率，另一种是控制并发连接数。

##### **控制速率**

我们需要使用 limit_req_zone 用来限制单位时间内的请求数，即速率限制，

因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500 毫秒内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。

*   **控制速率优化版**
    

上面的速率控制虽然很精准但是在生产环境未免太苛刻了，实际情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那样精确到毫秒，我们可以使用 burst 关键字开启此设置。

burst=4 意思是每个 IP 最多允许 4 个突发请求

##### **控制并发数**

利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数

其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。

注意：只有当 request header 被后端处理后，这个连接才进行计数。﻿

降级

**简介**

降级是在高并发或异常情况下舍弃非关键业务或简化处理的一种技术手段。

按类型可分为有感降级，无感降级。

### 有感降级

主要是通过一定的监控感知到异常出现或即将出现，对调用服务进行快速失败返回或者进行切换，在指标回正的时候恢复服务调用，这个也可以称为熔断。

### 无感降级

系统不作感知，在调用服务出现异常则自动忽略，进行空返回或无操作。降级的本质为作为服务调用方去规避提供方带来的风险。

**原理**

在限流中，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机会有三种状态：关闭（调用远程服务）、半打开（尝试调用远程服务）和打开（返回错误）。这三种状态之间切换的过程如下：﻿

当调用失败的次数累积到一定的阈值时，熔断机制从关闭态切换到打开态。一般在实现时，如果调用成功一次，就会重置调用失败次数。

当熔断处于打开状态时，我们会启动一个计时器，当计时器超时后，状态切换到半打开态。也可以通过设置一个定时器，定期的探测服务是否恢复。

当熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态；如果出现调用失败的情况，则切换到打开态。

![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJlRgK6EYMp8u2TxYwwJfGgGIXwUxtzRnXEsa8POZmibn31rq3VOG20WlqDmHKcSYAqN2ibCjxdgG2g/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)﻿﻿

**常用工具**

1. 降级开源组件：**sentinel 和 Hystrix(不展开)**

2. 手动降级：可采用系统配置开关来控制

**其他**

### 熔断

#### **简介**

熔断在程序中，表示 “断开” 的意思。如发生了某事件，程序为了整体的稳定性，所以暂时（断开）停止服务一段时间，以保证程序可用时再被使用。

#### **熔断和降级的区别**

*   概念不同
    
    熔断程序为了整体的稳定性，所以暂时（断开）停止服务一段时间；降级（Degradation）降低级别的意思，它是指程序在出现问题时，仍能保证有限功能可用的一种机制；
    
*   触发条件不同
    
    不同框架的熔断和降级的触发条件是不同，以 Hystrix 为例：
    

*   Hystrix 熔断触发条件
    

默认情况 hystrix 如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求。

*   Hystrix 降级触发条件
    

默认情况下，hystrix 在以下 4 种条件下都会触发降级机制：

1. 方法抛出 HystrixBadRequestException

2. 方法调用超时

3. 熔断器开启拦截调用

4. 线程池或队列或信号量已满

*   归属关系不同
    
    熔断时可能会调用降级机制，而降级时通常不会调用熔断机制。因为熔断是从全局出发，为了保证系统稳定性而停用服务，而降级是退而求其次，提供一种保底的解决方案，所以它们的归属关系是不同（熔断 > 降级）。
    

小结

*   缓存、限流和降级是应对高并发的三大利器，能够提升系统性能、保护资源和保证核心功能。
    
*   组合使用缓存、限流和降级策略，根据具体场景灵活调整和优化。
    
*   在高并发环境下，综合使用三大利器是应对挑战的有效策略。