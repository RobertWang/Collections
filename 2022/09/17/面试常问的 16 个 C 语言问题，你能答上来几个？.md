> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzkwNDMwNjYxNQ==&mid=2247484891&idx=1&sn=604aebf2d64b7c753a747071a1ad31b8&chksm=c0884f03f7ffc61521ac0b5aef61ae735d764cae3b9e4af553818590d910f6a991dab593f245&mpshare=1&scene=1&srcid=0912Cf2svaTAZse1PeWAP4UL&sharer_sharetime=1662963397277&sharer_shareid=8a467675e94cd5b11b6640b7770d6cc6#rd)

```
整理：小麦大叔 
来源：https://www.cnblogs.com/hjhgogo/p/9953506.html

```

1
-

用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒（忽略闰年问题）

```
#define SEC_YEAR  (365*24*60*60)UL


```

考察点：

1.  `#define` 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
    
2.  懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
    
3.  意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整型数
    
4.  如果你在你的表达式中用到 UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
    

2
-

写一个 "标准" 宏 MIN ，这个宏输入两个参数并返回较小的一个。

```
#define MIN(a,b)  ((a)<=(b)?(a):(b))


```

考察点：

1.  标识 #define 在宏中应用的基本知识。这是很重要的。因为在 嵌入 (inline) 操作符 变为标准 C 的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
    
2.  懂得在宏中小心地把参数用括号括起来
    
3.  我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
    

```
   least = MIN(*p++, b);


```

宏定义的作用结果`MIN(*p++,b) ((*p++)<(b)?(*p++),b)`  指针 p 会做两次自增操作

如何消除宏的副作用

```
#include <stdio.h>
#define min_i(x,y)    ((x)<=(y)?(x):(y))      //（1）
#define min_t(type,x,y) ({type _x = x;\       //（2）
                        type _y = y;\
                        _x<_y?_x:_y;\
                        })
#define min(x,y)    {const typeof(x)  _x = (x);\  //（3）
                    const typeof(y) _y = (y);\
                    (void)(&_x=&_y);\      //（4）
                    _x<_y?_x:_y;\
                    })

int main()
{
    int a = 10;
    int b = 20;
    printf("min_i(a++,b++)=%d\n",min_i(a++,b++));  //11
    printf("a=%d\n",a);  //12
    printf("b=%d\n",b);  //21

    a=10;
    b=20;
    printf("min_t(int,a++,b++)=%d\n",min_t(int,a++,b++));  //10
    printf("a=%d\n",a);  //11
    printf("b=%d\n",b);  //21

    a=10;
    b=20;
    printf("min(a++,b++)=%d\n",min(a++,b++));  //10
    printf("a=%d\n",a);  //11
    printf("b=%d\n",b);  //21
  
}


```

1.  这个定义计算 x 和 y 分别两次（x 和 y 中的小者被计算两次)，当参数由副作用时，将产生不正确的结果
    
2.  使用语句表达式只计算参数一次，避免了可能的错误，语句表达式通常用于宏定义
    
3.  typeof(x) 表示 x 的值类型
    
4.  检查参数 x 和 y 的类型是否相同 (如果 x 和 y 的类型不同编译器将会发出 warning，并不影响后面语句的运行
    

3
-

预处理器标识 #error 的目的是什么？

编译程序时，只要遇到 #error 就会跳出一个编译错误，既然是编译错误，要它干嘛呢？其目的就是保证程序是按照你所设想的那样进行编译的。

下面举个例子：程序中往往有很多的预处理指令

```
#ifdef XXX
  ...
#else
  ...
#endif


```

当程序比较大时，往往有些宏定义是在外部指定的（如 makefile），或是在系统头文件中指定的，当你不太确定当前是否定义了 XXX 时，就可以改成如下这样进行编译：

```
#ifdef XXX
...
#error "XXX has been defined"
#else

#endif


```

这样, 如果编译时出现错误, 输出了`XXX has been defined`, 表明宏`XXX`已经被定义了。

4
-

嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？

```
while(1)
{}


```

```
for(;;)
{}


```

```
loop:...
 
goto loop;


```

5
-

用变量 a 给出下面的定义

*   a) 一个整型数（An integer）
    
*   b) 一个指向整型数的指针（ A pointer to an integer）
    
*   c) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）
    
*   d) 一个有 10 个整型数的数组（ An array of 10 integers）
    
*   e) 一个有 10 个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）
    
*   f) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers）
    
*   g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
    
*   h)  一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 （ An array of ten pointers to functions that take an integer argument and return an integer ）
    

```
a)int a;

b)int *a;

c)int **a;

d)int a[10]

e)int *a[10]

f)int (*a)[10]

g)int (*a)(int a)

h)int (*a[10])(int)


```

6
-

关键字 static 的作用是什么？

在 C 语言中，关键字 static 有三个明显的作用：

*   **第一**、在修饰变量的时候，static 修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
    
*   **第二**、static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
    
*   **第三**、static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static 修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为 0；
    

*   （1）不想被释放的时候，可以使用 static 修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰
    
*   （2）考虑到数据安全性（当程想要使用全局变量的时候应该先考虑使用 static）
    

-------------------------------------------------------------------------

**在 C++ 中 static 关键字除了具有 C 中的作用还有在类中的使用**在类中，static 可以用来修饰静态数据成员和静态成员方法**静态数据成员**

*   （1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
    
*   （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
    
*   （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若为对静态数据成员赋初值，则编译器会自动为其初始化为 0
    
*   （4）静态数据成员既可以通过对象名引用，也可以通过类名引用。
    

**静态成员函数**

*   （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
    
*   （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
    
*   （3）静态成员函数主要用来方位静态数据成员而不能访问非静态成员。
    

7
-

关键字 const 有什么含意？

只要一个变量前用 const 来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着 const“只读”（readonly）。

规则：const 离谁近，谁就不能被修改；

const 修饰一个变量时，一定要给这个变量初始化，若不初始化，在后面也不能初始化。

**const 作用**：

*   1：可以用来定义常量，修饰函数参数，修饰函数返回值 ，且被 const 修饰的东西，都受到强制保护，可以预防其它代码无意识的进行修改，从而提高了程序的健壮性（是指系统对于规范要求以外的输入能够判断这个输入不符合规范要求，并能有合理的处理方式。ps：即所谓高手写的程序不容易死）；
    
*   2：使编译器保护那些不希望被修改的参数，防止无意代码的修改，减少 bug；
    
*   3：给读代码的人传递有用的信息，声明一个参数，是为了告诉用户这个参数的应用目的；
    

**const 优点**：

*   1：编译器可以对 const 进行类型安全检查（所谓的类型安全检查，能将程序集间彼此隔离开来，这种隔离能确保程序集彼此间不会产生负面影响，提高程序的可读性）；
    
*   2：有些集成化的调试工具可以对 const 常量进行调试，使编译器对处理内容有了更多的了解，消除了一些隐患。eg：void hanshu（const int i）{.......}  编译器就会知道 i 是一个不允许被修改的常量
    
*   3：可以节省空间，避免不必要的内存分配，因为编译器通常不为 const 常量分配内存空间，而是将它保存在符号表中，这样就没有了存储于读内存的操作，使效率也得以提高；
    
*   4：可以很方便的进行参数的修改和调整，同时避免意义模糊的数字出现
    

8
-

关键字`volatile`有什么含意？并给出三个不同的例子。

一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：

*   1：并行设备的硬件寄存器（如：状态寄存器）
    
*   2：一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables)
    
*   3：多线程应用中被几个任务共享的变量
    

9
-

嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 a，写两段代码，第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其它位不变。

考察点：

*   1：不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
    
*   2：用 bit fields。Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可 重用的。
    
    最近不幸看到 Infineon 为其较复杂的通信芯片写的驱动程序，它用到了 bit fields 因此完全对我无用，因为我的编译器用其它的方 式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
    
*   3：用 `#defines` 和 `bit masks` 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
    

```
#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void)
{
    a |= BIT3;
}
void clear_bit3(void)
{
    a &= ~BIT3;
}


```

10
--

嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的 ANSI 编译器。写代码去完成这一任务。

**考察点**：

这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。

```
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;

......

*(int *const)(0x67a9) = 0xaa66;


```

11
--

中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准 C 支持中断。具代表事实是，产生了一个新的关键字  __interrupt。下面的代码就使用了__interrupt 关键字去定义了一个中断服务子程序 (ISR)，请评论一下这段代码的。

```
__interrupt double compute_area (double radius)
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}


```

考察点：

*   1：ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
    
*   2：ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
    
*   3：在许多的处理器 / 编译器中，浮点一般都是不可重入的。有些处理器 / 编译器需要让额处的寄存器入栈，有些处理器 / 编译器就是不允许在 ISR 中做浮点运算。此外，ISR 应该是短而有效率的，在 ISR 中做浮点运算是不明智的。
    
*   4：与第三点一脉相承，printf() 经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
    

12
--

下面的代码输出是什么，为什么？

```
void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}


```

考察点：

这 个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。

不管如何，这无符号整型问题的答案是输出是 ">6"。原因 是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。

因此 - 20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。

如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13
--

评价下面的代码片断：

```
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1's complement of zero */


```

考察点：

对于一个 int 型不是 16 位的处理器为说，上面的代码是不正确的。应编写如下：

`unsigned int compzero = ~0;`

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而 PC 机程序往往把硬件

作为一个无法避免的烦恼。

到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。

但如果显然应试者做得不错，那么我就 扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如 何，你就当是这个娱乐吧...

14
--

尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。

那么嵌入式系统中，动态分配内存可能发生的问题是什么？

这 里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在 ESP 杂志中被广泛地讨论过了（主要是  P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么 一个小节目：下面的代码片段的输出是什么，为什么？

```
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
  puts("Got a null pointer");
else
  puts("Got a valid pointer");


```

这 是一个有趣的问题。最近在我的一个同事不经意把 0 值传给了函数 malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输 出是 "Got a valid pointer"。

我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。

**得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。**

15
--

Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

```
#define dPS struct s *
typedef struct s * tPS;


```

以上两种情况的意图都是要定义`dPS` 和 `tPS` 作为一个指向结构 s 指针。哪种方法更好呢？（如果有的话）为什么？

考察点：

这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef 更好。思考下面的例子：

```
dPS p1,p2;
tPS p3,p4;


```

第一个扩展为

```
struct s * p1, p2;


```

上面的代码定义 p1 为一个指向结构的指，p2 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 p3 和 p4 两个指针。

16
--

C 语言同意一些令人震惊的结构, 下面的结构是合法的吗，如果是它做些什么？

```
int a = 5, b = 7, c;
c = a+++b;


```

**考察点**：

这个问题将作为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

```
c = a++ + b;


```

因此, 这段代码持行后 a = 6, b = 7, c = 12。

*   如果你知道答案，或猜出正确答案，做得好。
    
*   如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。