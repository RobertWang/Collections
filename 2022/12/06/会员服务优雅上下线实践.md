> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560618&idx=1&sn=9937ce5134cf07894bf22d67128719e1&chksm=81398eb2b64e07a44f3cc7c5b8fead9c67a21fed37faed1767c67bb8b840f843167a3b7b6b75&mpshare=1&scene=1&srcid=08311ChSAX5cVMz5SPExbehM&sharer_sharetime=1661930745242&sharer_shareid=8a467675e94cd5b11b6640b7770d6cc6#rd)

**问题分析**

####  **异常情况分析** 

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibcLxunOJGjicEecsvCicgdNsyAiamoJDXgnlSA1elOibQ5QaiamyBquzmzQRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

通过梳理服务流程发现，引起服务可用性降低、响应时间突增的原因有以下几点：

*   **过早销毁对象：**服务正在处理请求，但此时对象被销毁导致请求报错。
    
*   **服务未及时下线：**调用方不能及时感知服务已在下线中，仍会发送请求过来，但此时对象可能已经被销毁导致请求报错。
    
*   **过早注册服务：**服务未初始化完成就被注册到了注册中心，导致接口响应时间突增甚至超时。
    

####  **优化方向** 

基于上面的分析，可以通过以下方式解决相关的问题：

1.  在上线过程中，当服务把依赖的资源都初始化完成后，才将实例注册到注册中心。
    
2.  在下线过程中，服务调用方可以排除正在下线的实例，保证在一定的时间窗口内请求不会打到这个实例上。
    

**02**

**解决方案**

系统以集群方式提供服务，实例的上下线状态对业务无感知，由组件封装实例的状态转换，通过优雅上线、优雅下线组合来保证服务的无损发布。

####  **优雅上线** 

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibc34KZwImIDzFjMVUDIVIeq5knO2BGBScupTpmzpXGnzIj9SN2pIpHyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

通过预热功能实现资源初始化，预热模块是可插拔的，可全使用或者仅使用其中一个模块：

1.  **自定义预热：**由业务方自行扩展实现预热逻辑。
    
2.  **线上请求回放预热：**配置预热接口，拉取线上请求对本地服务预热，当接口调用达到配置的预热次数后，再将服务注册到注册中心。
    

*   **预热**
    

在原生 Spring Cloud Netflix 基础上，定制开发了服务注册组件 GracefulServiceRegistration 并抽象了预热组件 WarmUp。在 Spring 容器初始化过程中，会扫描所有 WarmUp 实现类并注入到容器中，启动完成后由 GracefulServiceRegistration 组件调用 WarmUp 接口所有实现类的预热方法进行服务预热，预热完成之后再进行服务注册。

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibc6bKpXlLASBo3jsKWWftQqeib5Gy8LhOxUo06P5Tj2m2t8fxEGziaU8UA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

图例说明：

*   VClientAutoConfiguration：服务注册配置类，负责初始化 GracefulServiceRegistration
    
*   GracefulServiceRegistration：服务注册类，触发服务预热逻辑执行
    
*   WarmUp: 预热组件，由业务方自行扩展实现预热逻辑。框架默认实现: 延迟 5s(可配置) 再执行服务注册、线上请求回放预热
    

####  **优雅下线** 

优雅下线通过延迟下线和可靠负载功能组合实现，在下线过程中，服务实例需要先去取消注册并将自己标记为已下线，后续的接口请求都将获取到该实例的已下线标记。服务调用方根据下线标记把该实例从可用服务列表中剔除，保证在后续一定时间窗口内的请求都不会再打到这个实例上。具体交互流程见下图：

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibcUHHoBencbG8ObZ00bUStPQZkxw8WB19WIf03zluohvbL2nDzSGsWyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

*   ##### **延迟下线**
    

上文提到在原生 Spring Cloud Netflix 基础上，定制开发了 GracefulServiceRegistration、WarmUp 等组件，在解决优雅下线问题时，我们又增加了调用插件 InvokePlugin。当 JVM 监听到 SIGTERM 信号时，下线钩子线程开始工作，先执行取消注册，然后通过 GracefulServiceRegistration 标记当前服务为下线中状态，并阻塞当前线程 5s（可配置）来保证当前正在处理的请求能够成功返回。如果此时收到调用方请求，InvokePlugin 会检查当前服务状态是否为下线中，如果是，直接返回下线标记。最后下线钩子线程被唤醒，再执行对象销毁逻辑。

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibcicPWlkZ2c9nvPicHBh5rmhRjKNsu90wGaMU4uOZrrC5qSZWmW4yIHGWw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

图例说明：

*   VClientAutoConfiguration：服务注册配置类，负责初始化 InvokePlugin、GracefulServiceRegistration 等组件
    
*   GracefulServiceRegistration：服务注册类，负责延迟销毁对象、触发服务预热逻辑执行
    
*   InvokePlugin：请求调用插件类，负责执行请求时检查服务实例状态是否在下线中，如果在下线中，直接返回下线标记
    

*   ##### **可靠负载**
    

微服务框架使用 Ribbon 作为负载均衡策略，默认是轮询机制，BaseLoadBalancer 中维护了两个注册表集合：全量注册表 allServerList、可用注册表 upServerList，但是原生只使用了全量注册表，通过循环判断获取可用实例，这种方式可能会获取到不可用的实例，所以我们对逻辑进行了优化，新增一个路由规则，使用可用注册表保存可用服务实例，并增加任务剔除标记已下线的实例。

负载策略实现方式为，服务调用方接收到实例的下线标记时，将该实例加入失活队列，独立的任务线程处理失活队列，并维护可用注册表，且失活队列的另一个任务是在同步注册中心最新注册表的时候，不要把已排除的实例恢复到可用注册表中。通过重试 + 排除下线实例的方式，使业务得到更高的可用性。具体设计如下：

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibceF1WibtreBaj1jOzO37aDYklo2Env46U7mTSbJklbIsymWflukDUEwA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**03**

**成果与总结**

对接优雅上下线功能的服务在上线过程中，服务成功率可以提升到 99.99% 以上，有效解决了服务上线成功率的问题。对比数据见下图示例：

![](https://mmbiz.qpic.cn/mmbiz_jpg/unymlvueOvviccML3hgIxfbvdAWudIMibcL8hRLlFkTBmKpzeicAq4xHpzkDe8buKTv95C1PJGw3KicXYY4ScnLiadw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

**无优雅上下线（并行 1 台滚动上线）**

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibcUEEQpqP6ORlnvy2n1IXxWmqvwoibM50nD1fYPYlvff3z5npXaJ1mKEA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**开启优雅上下线（并行 1 台滚动上线）**

![](https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvviccML3hgIxfbvdAWudIMibcfXgQxtseTGVzTcqpfCnZspGhPkeuuM2AiaTZ4IFHpp5xMUwhdg4HWEg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**参考阅读：**

*   [可视化服务编排在金融 APP 中的实践](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560591&idx=1&sn=f2587ffeef8bad1f172a1bca6ffd7db7&chksm=81398e97b64e078175c7bdbfd23efd35b1c96333056615538fb40d904c0d1d1bd2f06c3cd308&scene=21#wechat_redirect)
    
*   [长路漫漫, 从 Blink-tree 到 Bw-tree (上)](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560547&idx=1&sn=43e07d505738d13f65aa0a9933490008&chksm=81398f7bb64e066de29f77302ed03339372ec86e12ab47d6933197cd530344ff22c418ce8534&scene=21#wechat_redirect)
    
*   [Redis 定长队列的探索和实践](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560524&idx=1&sn=89886ead30a9e6e128b9a8595e518250&chksm=81398f54b64e06422f17f7b3b237cd5e988dadff394c9d4f1fc3f7d2f417bd371abaddad78e6&scene=21#wechat_redirect)
    
*   [31 个！Golang 常用工具来啦（建议收藏）](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560503&idx=1&sn=9ff34c9f76a32b110117f2fadea6b0d2&chksm=81398f2fb64e0639a40ad6ac1486159ebe76bd8ea6e2ca63caff5f70d5f644694972153fa47f&scene=21#wechat_redirect)
    
*   [京东科技埋点数据治理和平台建设实践](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653560445&idx=1&sn=821e2c91335ed907421677b73dec17ac&chksm=81398fe5b64e06f31cea407711da55b73f07255851f3edc4c1f5614b303a6bf60b3d285eb2a5&scene=21#wechat_redirect)