> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [jesseduffield.com](https://jesseduffield.com/Testing-Private-Methods/)

> 昨天，当我在 Rust 上运行一个会话时，我不经意地说‘我想我们都可以同意......

昨天，当我在 Rust 上运行一个会话时，我随口说“我想我们都同意，在编写单元测试时，私有方法不应该直接测试，除非在某些特殊情况下”，令我惊讶的是，我想错了. 一场小型辩论爆发了，各种人争论相互不相容的观点。我们很快就结束了辩论，但我有点尴尬，因为我误判了开发者的时代精神。

当然，在整个开发人员行业中，现在大多数人都同意一种观点，对吧？再猜。如果您想了解关于这个主题的共识有多么少，请阅读这些 Stack Overflow 帖子：[here](https://stackoverflow.com/questions/9122708/unit-testing-private-methods-in-c-sharp)、[here](https://stackoverflow.com/questions/48011295/how-to-unit-test-this-private-method)、[here](https://stackoverflow.com/questions/34571/how-do-i-test-a-class-that-has-private-methods-fields-or-inner-classes)和[here](https://stackoverflow.com/questions/5601730/should-private-protected-methods-be-under-unit-test)。有人说我们应该总是直接测试私有方法，也有人说我们不应该直接测试私有方法。他们不可能都是对的！是否有最适合软件开发现实的观点？

关于测试私有方法的话题有五种流行的观点：

*   首先不要使用私有方法
*   始终测试私有方法
*   永远不要测试私有方法
*   有时测试私有方法
*   将私有方法提取到单独的类中

在这篇文章中，我将讨论每个观点，然后将它们综合成我自己的经验法则，希望大多数人都能同意。请注意，我们将根据类和方法进行讨论，但相同的观点同样适用于函数式语言中的普通旧函数。

观点 1：首先不要使用私有方法
---------------

我将把这个观点排除在外，因为大多数人直觉地觉得它有点极端，如果正确，它将完全使其余的辩论无效！

这种观点与其说是对测试私有方法的攻击，不如说是对试图预测未来的攻击。这个想法是，在编写库代码时，您不可能提前知道您的客户想要使用什么方法，并且默认为私有方法会给您和您的客户带来比默认为公共（或受保护）更多的问题。这种思路似乎是库开发人员所独有的（参见[此处](https://osoco.es/thoughts/2018/10/the-case-against-private-methods/)，[此处](https://stackoverflow.com/questions/8353272/private-vs-protected-visibility-good-practice-concern)），因为应用程序开发人员可以通过几次按键轻松公开方法，而库的客户要么需要分叉库，要么提出问题并等待响应.

这种观点有缺点：将私有方法提升到公共很容易，但是从公共降级到私有是一个突破性的变化。此外，您的公共 API 会与客户沟通您希望他们如何使用您的库。为了假设的用例，通过使用可能的私有方法来膨胀你的公共 API，你会让所有只想知道如何满足已知用例的客户的生活变得更加艰难。这些缺点是交织在一起的：客户端错误地使用错误的方法与您的库进行交互，这反过来又使重构变得更加困难。

观点 2：始终测试私有方法
-------------

尽管这是一个不受欢迎的观点，但仍然[有一些](https://oli.me.uk/test-private-methods/)支持者。有三个主要论点：

*   在进行测试驱动开发 (TDD) 时，您需要在编写代码之前编写测试，因此您最好在每个方法的基础上执行此操作，无论您的方法是公共的还是私有的。
*   通过单独测试每个方法（无论访问修饰符如何），您可以让读者清楚地了解每个单独方法的预期行为，以便他们可以更好地理解每个方法在更大范围内所扮演的角色。
*   直接测试私有方法的明显替代方法是通过公共方法测试它们，但这需要在测试中设置代码，这需要更长的时间来编写，并且可能导致测试需要更长的时间来运行。如果您的首要任务是节省开发时间，并且您认为编写公共方法测试的前期成本高于重构时重写私有方法测试的持续成本，那么首先编写私有方法测试是有意义的放置并处理出现的持续成本。

有些语言比其他语言更容易测试私有方法。如果您的语言让您跳过箍来测试私有方法，那么您可能不同意这种观点。

观点 3：永远不要测试私有方法
---------------

与前面的观点截然相反，这个观点的主要论点是你的类的客户只能通过它的公共接口（即类上的公共方法集）与类交互，那么为什么你的测试应该是任何不同的？如果私有方法不能通过公共方法访问，那么它就是死代码，应该被删除。如果_可以_通过公共方法访问它，那么您_应该_通过该公共方法测试私有方法，因为如果不模拟将使用您的代码的客户，测试是什么？

这是哲学论点，但实际论点更容易推销：如果您的测试仅依赖于类的公共接口，那么您可以根据自己的需要重构该类的内部结构，而无需更改任何测试。如果您不需要更新测试，那么您可以确定失败的测试意味着您实际上破坏了某些东西，而完全绿色的测试套件意味着您已经成功地保留了类的原始行为。

相反，如果类的测试依赖于私有方法，并且您的重构删除或更改了任何这些方法的签名，您将需要重写这些测试以处理新的内部结构，但现在您对测试失去了信心，因为测试重写和代码重写一样容易出错！

其次是这样一个事实，即使您可以足够小心地重写测试以捕获与以前完全相同的行为，这仍然是一个费力且耗时的过程，因此会阻止可以改善代码库健康状况的重构。先前的观点更强调通过公共方法测试私有方法的前期成本，而这种观点更关心重构的持续成本。

观点 4：有时测试私有方法
-------------

先前的观点非常关心“公共接口”，但这种新观点对什么是真正的公共以及什么是真正的单元提出了质疑。如果您正在编写应用程序（运行二进制文件）而不是库（导出代码以用于其他代码库），那么只有一个真正的公共接口，即应用程序本身的接口，例如由用户的按键和鼠标点击。如果您想像先前观点所倡导的那样最大化重构能力，最好的方法是让每个测试都打开应用程序并模仿用户的点击和按键。这样，对任何内部代码的依赖都为零，您可以自信地重构代码，而无需重写任何测试。

在极少数情况下，端到端测试是最明智的选择，例如，当您继承了一个几乎不可能进行单元测试的系统并且您即将重构整个代码库时，或者当您正在构建参考实现，并希望针对这两种实现运行测试以实现功能/错误兼容性。然而，在大多数情况下，放弃所有单元测试，而是编写数以万计的端到端测试来模拟真实用户是荒谬的。仅包含端到端测试的测试套件存在问题的原因有以下几个：

*   运行给定的测试需要很长时间
*   编写给定的测试需要很长时间
*   每个测试的复杂性掩盖了它的意图，削弱了测试作为文档的能力。
*   改变一个特性可能会破坏关心另一个不相关特性的测试

正是出于这些原因，单元测试首先存在。作为开发人员，我们通过更深入地侵入我们的应用程序代码并选择我们认为值得单独测试的“单元”来妥协。我们这样做是知道如果重构导致一个这样的单元被抹杀，我们将需要在其他地方重写它的测试，并承担上述所有成本。

一旦我们开始测试对于我们的其他代码是公开的但对于最终用户是私有的代码，我们必须承认我们的“单元”选择过程固有的任意性。在类中测试私有方法和在应用程序中测试类之间的区别只是程度的不同，而不是种类的不同。

这为我们提供了一系列封装，从应用程序本身开始，向下移动到模块、类，最后到私有方法，因为我们将封装级别降低到越来越小的切片。封装级别越高，越难测试，但封装级别越低，越难重构。

这种观点认为，如果私有方法足够独立，并且通过公共接口对其进行测试是一件很痛苦的事情，那么可以直接对其进行测试而不会感到羞耻或内疚，否则断言是一种双重标准。

这个观点建立在前一个观点的基础上，如果你发现自己想要测试一个私有方法，这表明你的类可能有太多的责任，因此违反了单一责任原则 (SRP)。

在_Working With Legacy Code_中，作者 Michael Feathers 指出：

> 如果我们需要测试私有方法，我们应该将其公开。如果公开它让我们感到困扰，在大多数情况下，这意味着我们的班级做得太多，我们应该解决它。

（就个人而言，我无法想象_不会_因为纯粹为了测试而公开一个方法而烦恼，但你明白了）

在_Practical Object Oriented Design in Ruby 中_，Sandi Metz 还建议渴望被测试的私有方法是违反 SRP 的代码味道。

先前的观点认为“单位”的选择是任意的，而这种观点不同意。如果你想测试一些私有代码，这表明你偶然发现了一个在代码中没有明确表示的抽象边界。也许您想测试一些直接映射到问题域的算法，在这种情况下，应该将其提升为自己的抽象。

通过将私有方法提取到一个单独的类中，我们现在可以通过其公共接口测试该类，并且我们可以将新类作为依赖项注入到原始类中，从而使我们能够轻松模拟新类的行为这样代码和测试都保持职责分离。

如果将单个函数包装在一个类中感觉有点极端，并且您的语言允许函数存在于类之外，那么大概这种观点将私有方法提取到它自己的独立函数中没有问题，只要您可以切断它对任何实例变量的依赖。

讨论
--

我们从一个观点开始，提出了一个激进的主张，即首先没有方法应该是私有的。当然简化了测试过程，但缺乏封装会让生活变得悲惨。

然后我们考虑了两种完全矛盾的观点，一种不希望测试私有方法，另一种希望测试所有公共和私有方法。然后出现了第三种观点，并提出无论你在封装范围内的哪个位置，在更高（例如类）或更低（例如私有方法）级别进行测试都有利弊，如果利大于弊缺点，编写测试并不羞耻。

然后第四个观点出现了，并提出了需要测试的私有方法本身就是类有太多责任的代码气味，并在工作中抛出了一个扳手。

强调坚持类的公共 API 的观点 3 的支持者可能会对观点 5 说以下内容：坚持下去！到目前为止，我们一直在争论重构和封装，但是您已经将目标转移到了 SRP 上！将私有方法移动到私有类中并不能减轻重构时的负担：我们很可能需要丢弃/更改私有类，就像我们是私有方法一样，这意味着在任何一种情况下，测试仍然需要重写。这假设您的语言支持私有类，因为如果不支持，您刚刚扩展了公共 API 以包含一个您实际上不希望客户使用的类！当它只被一个类使用时，采用一个纯函数的私有方法并将其移动到一个完全独立的文件中真的有意义吗？这对可读性有何帮助？

观点 5 的支持者可能会反驳说，测试私有方法的愿望证明存在您未能识别的独立抽象，并且与您不需要的一些随机私有方法相比，该抽象不太可能需要重构。感觉需要直接测试。

我的建议
----

这是我建议的方法：尝试在您的类中使用尽可能精简的公共接口，将每个方法默认为私有。如果您发现自己想直接测试一组私有方法，请认真考虑提取一个类（或独立函数），但前提是它与您的测试需求无关。如果您想测试单个私有方法并且看不到将其从类中提取出来的意义，请将其转换为纯函数（不引用实例变量）并测试该方法。这样，如果稍后您决定将函数移动到其他地方，移动测试就像复制+粘贴一样简单。

我是否错过或歪曲了这场辩论中的任何观点？你不同意我的提议吗？我是否过度概括了？让我知道。直到下一次！

链接
--

*   [应该测试私有方法吗？](https://anthonysciamanna.com/2016/02/14/should-private-methods-be-tested.html)- 安东尼·夏曼纳
*   [使用 JUnit 和 SuiteRunner 测试私有方法](https://www.artima.com/articles/testing-private-methods-with-junit-and-suiterunner)- Bill Venners
*   [测试私有方法（不要这样做）](https://fishbowl.pastiche.org/2003/03/28/testing_private_methods_dont_do_it) - Charles Miller
*   [测试私有方法](https://oli.me.uk/test-private-methods/)- Oliver Caldwell
*   [反对私有方法的案例](https://osoco.es/thoughts/2018/10/the-case-against-private-methods/)- 何塞·圣莱德罗