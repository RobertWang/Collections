> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651163799&idx=1&sn=185636c23261b60b9b0c2277d69fc507&chksm=80645dc8b713d4de05bcd133ea02a9730e04eb18ef51b9bbace753c3b140b1d40e6d777c5dc9&scene=21#wechat_redirect)

一、预备知识—程序的内存分配  

一个由 c/C++ 编译的程序占用的内存分为以下几个部分

1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束后有系统释放

4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放

5、程序代码区—存放函数体的二进制代码。

例子程序
====

这是一个前辈写的，非常详细

```
//main.cpp
int a = 0; //全局初始化区
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main() {
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);
    //分配得来得10和20字节的区域就在堆区。
    strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}
```

二、堆和栈的理论知识
==========

2.1 申请方式
--------

stack:  
由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间

heap:  
需要程序员自己申请，并指明大小，在 c 中 malloc 函数

如`p1 = (char *)malloc(10);`

在 C++ 中用 new 运算符  

如`p2 = (char *)malloc(10);`  
但是注意 p1、p2 本身是在栈中的。

2.2 申请后系统的响应
------------

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，

会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

2.3 申请大小的限制
-----------

栈：在 Windows 下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

2.4 申请效率的比较：
------------

栈由系统自动分配，速度较快。但程序员是无法控制的。  
堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片, 不过用起来最方便.

另外，在 WINDOWS 下，最好的方式是用 VirtualAlloc 分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

2.5 堆和栈中的存储内容
-------------

栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

2.6 存取效率的比较
-----------

`char s1[] = "aaaaaaaaaaaaaaa";`  
`char *s2 = "bbbbbbbbbbbbbbbbb";`  
aaaaaaaaaaa 是在运行时刻赋值的；  
而 bbbbbbbbbbb 是在编译时就确定的；  

但是，在以后的存取中，在栈上的数组比指针所指向的字符串 (例如堆) 快。

比如：

```
＃include
void main() {
    char a = 1;
    char c[] = "1234567890";
    char *p ="1234567890";
    a = c[1];
    a = p[1];
    return;
}
```

对应的汇编代码

```
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
```

第一种在读取时直接就把字符串中的元素读到寄存器 cl 中，而第二种则要先把指针值读到 edx 中，在根据 edx 读取字符，显然慢了。

2.7 小结：
-------

堆和栈的区别可以用如下的比喻来看出：

使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

三 、windows 进程中的内存结构
===================

在阅读本文之前，如果你连堆栈是什么多不知道的话，请先阅读文章后面的基础知识。

接触过编程的人都知道，高级语言都能通过变量名来访问内存中的数据。那么这些变量在内存中是如何存放的呢？程序又是如何使用这些变量的呢？下面就会对此进行深入的讨论。下文中的 C 语言代码如没有特别声明，默认都使用 VC 编译的 release 版。

首先，来了解一下 C 语言的变量是如何在内存分部的。C 语言有全局变量 (Global)、本地变量 (Local)，静态变量 (Static)、寄存器变量 (Regeister)。每种变量都有不同的分配方式。先来看下面这段代码：

```
＃include <stdio.h>
int g1=0, g2=0, g3=0;
int main()
{
    static int s1=0, s2=0, s3=0;
    int v1=0, v2=0, v3=0;
    //打印出各个变量的内存地址    
    printf("0x%08x\n",&v1); //打印各本地变量的内存地址
    printf("0x%08x\n",&v2);
    printf("0x%08x\n\n",&v3);
    printf("0x%08x\n",&g1); //打印各全局变量的内存地址
    printf("0x%08x\n",&g2);
    printf("0x%08x\n\n",&g3);
    printf("0x%08x\n",&s1); //打印各静态变量的内存地址
    printf("0x%08x\n",&s2);
    printf("0x%08x\n\n",&s3);
    return 0;
}
```

编译后的执行结果是：

```
0x0012ff78
0x0012ff7c
0x0012ff80

0x004068d0
0x004068d4
0x004068d8

0x004068dc
0x004068e0
0x004068e4
```

输出的结果就是变量的内存地址。其中 v1,v2,v3 是本地变量，g1,g2,g3 是全局变量，s1,s2,s3 是静态变量。你可以看到这些变量在内存是连续分布的，但是本地变量和全局变量分配的内存地址差了十万八千里，而全局变量和静态变量分配的内存是连续的。这是因为本地变量和全局 / 静态变量是分配在不同类型的内存区域中的结果。对于一个进程的内存空间而言，可以在逻辑上分成 3 个部份：代码区，静态数据区和动态数据区。

**动态数据区一般就是 “堆栈”。“栈(stack)” 和“堆 (heap)” 是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构**。进程的每个线程都有私有的 “栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址” 和“栈顶”地址来描述。**全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中**。程序通过堆栈的基地址和偏移量来访问本地变量。

```
├———————┤低端内存区域
│ …… │
├———————┤
│ 动态数据区 │
├———————┤
│ …… │
├———————┤
│ 代码区 │
├———————┤
│ 静态数据区 │
├———————┤
│ …… │
├———————┤高端内存区域
```

_堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址_。我们可以先了解一下函数调用的过程，以便对堆栈在程序中的作用有更深入的了解。不同的语言有不同的函数调用规定，这些因素有参数的压入规则和堆栈的平衡。

windows API 的调用规则和 ANSI C 的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过 “__stdcall” 和“__cdecl”前缀区分。先看下面这段代码：

```
＃include <stdio.h>
void __stdcall func(int param1,int param2,int param3)
{
    int var1=param1;
    int var2=param2;
    int var3=param3;
    printf("0x%08x\n",param1); //打印出各个变量的内存地址
    printf("0x%08x\n",param2);
    printf("0x%08x\n\n",param3);
    printf("0x%08x\n",&var1);
    printf("0x%08x\n",&var2);
    printf("0x%08x\n\n",&var3);
    return;
}

int main() {
    func(1,2,3);
    return 0;
}
```

编译后的执行结果是：

```
0x0012ff78
0x0012ff7c
0x0012ff80

0x0012ff68
0x0012ff6c
0x0012ff70
```

```
├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
│ …… │
├———————┤
│ var 1 │
├———————┤
│ var 2 │
├———————┤
│ var 3 │
├———————┤
│ RET │
├———————┤<—“__cdecl”函数返回后的栈顶（ESP）
│ parameter 1 │
├———————┤
│ parameter 2 │
├———————┤
│ parameter 3 │
├———————┤<—“__stdcall”函数返回后的栈顶（ESP）
│ …… │
├———————┤<—栈底（基地址 EBP）、高端内存区域
```

上图就是函数调用过程中堆栈的样子了。

首先，三个参数以从右到左的次序压入堆栈，先压 “param3”，再压 “param2”，最后压入 “param1”；然后压入函数的返回地址 (RET)，接着跳转到函数地址接着执行（这里要补充一点，介绍 UNIX 下的缓冲溢出原理的文章中都提到在压入 RET 后，继续压入当前 EBP，然后用当前 ESP 代替 EBP。

然而，有一篇介绍 windows 下函数调用的文章中说，在 windows 下的函数调用也有这一步骤，但根据我的实际调试，并未发现这一步，这还可以从 param3 和 var1 之间只有 4 字节的间隙这点看出来）；

第三步，将栈顶 (ESP) 减去一个数，为本地变量分配内存空间，上例中是减去 12 字节 (ESP=ESP-3*4，每个 int 变量占用 4 个字节)；接着就初始化本地变量的内存空间。由于“__stdcall” 调用由被调函数调整堆栈，所以在函数返回前要恢复堆栈，先回收本地变量占用的内存(ESP=ESP+3*4)，然后取出返回地址，填入 EIP 寄存器，回收先前压入参数占用的内存(ESP=ESP+3*4)，继续执行调用者的代码。

参见下列汇编代码：

```
;--------------func 函数的汇编代码-------------------

:00401000 83EC0C sub esp, 0000000C //创建本地变量的内存空间
:00401003 8B442410 mov eax, dword ptr [esp+10]
:00401007 8B4C2414 mov ecx, dword ptr [esp+14]
:0040100B 8B542418 mov edx, dword ptr [esp+18]
:0040100F 89442400 mov dword ptr [esp], eax
:00401013 8D442410 lea eax, dword ptr [esp+10]
:00401017 894C2404 mov dword ptr [esp+04], ecx

……………………（省略若干代码）

:00401075 83C43C add esp, 0000003C ;恢复堆栈，回收本地变量的内存空间
:00401078 C3 ret 000C ;函数返回，恢复参数占用的内存空间
;如果是“__cdecl”的话，这里是“ret”，堆栈将由调用者恢复

;-------------------函数结束-------------------------

;--------------主程序调用func函数的代码--------------

:00401080 6A03 push 00000003 //压入参数param3
:00401082 6A02 push 00000002 //压入参数param2
:00401084 6A01 push 00000001 //压入参数param1
:00401086 E875FFFFFF call 00401000 //调用func函数
;如果是“__cdecl”的话，将在这里恢复堆栈，“add esp, 0000000C”
```

聪明的读者看到这里，差不多就明白缓冲溢出的原理了。先来看下面的代码：

```
＃include <stdio.h>
＃include <string.h>

void __stdcall func() {
    char lpBuff[8]="\0";
    strcat(lpBuff,"AAAAAAAAAAA");
    return;
}

int main() {
    func();
    return 0;
}
```

编译后执行一下回怎么样？哈，“”0x00414141” 指令引用的”0x00000000” 内存。该内存不能为”read”。”，“非法操作” 喽！”41” 就是”A” 的 16 进制的 ASCII 码了，那明显就是 strcat 这句出的问题了。”lpBuff” 的大小只有 8 字节，算进结尾的 \ 0，那 strcat 最多只能写入 7 个”A”，但程序实际写入了 11 个”A” 外加 1 个 \ 0。再来看看上面那幅图，多出来的 4 个字节正好覆盖了 RET 的所在的内存空间，导致函数返回到一个错误的内存地址，执行了错误的指令。

如果能精心构造这个字符串，使它分成三部分，前一部份仅仅是填充的无意义数据以达到溢出的目的，接着是一个覆盖 RET 的数据，紧接着是一段 shellcode，那只要这个 RET 地址能指向这段 shellcode 的第一个指令，那函数返回时就能执行 shellcode 了。但是软件的不同版本和不同的运行环境都可能影响这段 shellcode 在内存中的位置，那么要构造这个 RET 是十分困难的。一般都在 RET 和 shellcode 之间填充大量的 NOP 指令，使得 exploit 有更强的通用性。

```
├———————┤<—低端内存区域
│ …… │
├———————┤<—由exploit填入数据的开始
│ │
│ buffer │<—填入无用的数据
│ │
├———————┤
│ RET │<—指向shellcode，或NOP指令的范围
├———————┤
│ NOP │
│ …… │<—填入的NOP指令，是RET可指向的范围
│ NOP │
├———————┤
│ │
│ shellcode │
│ │
├———————┤<—由exploit填入数据的结束
│ …… │
├———————┤<—高端内存区域
```

windows 下的动态数据除了可存放在栈中，还可以存放在堆中。了解 C++ 的朋友都知道，C++ 可以使用 new 关键字来动态分配内存。来看下面的 C++ 代码：

```
＃include <stdio.h>
＃include <iostream.h>
＃include <windows.h>

void func()
{
    char *buffer=new char[128];
    char bufflocal[128];
    static char buffstatic[128];
    printf("0x%08x\n",buffer); //打印堆中变量的内存地址
    printf("0x%08x\n",bufflocal); //打印本地变量的内存地址
    printf("0x%08x\n",buffstatic); //打印静态变量的内存地址
}

void main() {
    func();
    return;
}
```

程序执行结果为：

```
0x004107d0
0x0012ff04
0x004068c0
```

可以发现用 new 关键字分配的内存即不在栈中，也不在静态数据区。VC 编译器是通过 windows 下的 “堆(heap)” 来实现 new 关键字的内存动态分配。在讲 “堆” 之前，先来了解一下和 “堆” 有关的几个 API 函数：

```
- HeapAlloc 在堆中申请内存空间
- HeapCreate 创建一个新的堆对象
- HeapDestroy 销毁一个堆对象
- HeapFree 释放申请的内存
- HeapWalk 枚举堆对象的所有内存块
- GetProcessHeap 取得进程的默认堆对象
- GetProcessHeaps 取得进程所有的堆对象
- LocalAlloc
- GlobalAlloc
```

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为 1M。堆对象由系统进行管理，它在内存中以链式结构存在。通过下面的代码可以通过堆动态申请内存空间：

```
HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,8);
```

其中 hHeap 是堆对象的句柄，buff 是指向申请的内存空间的地址。那这个 hHeap 究竟是什么呢？它的值有什么意义吗？看看下面这段代码吧：

```
#pragma comment(linker,"/entry:main") //定义程序的入口
＃include <windows.h>

_CRTIMP int (__cdecl *printf)(const char *, ...); //定义STL函数printf
/*---------------------------------------------------------------------------
 写到这里，我们顺便来复习一下前面所讲的知识：
 (*注)printf函数是C语言的标准函数库中函数，VC的标准函数库由msvcrt.dll模块实现。
 由函数定义可见，printf的参数个数是可变的，函数内部无法预先知道调用者压入的参数个数，函数只能通过分析第一个参数字符串的格式来获得压入参数的信息，由于这里参数的个数是动态的，所以必须由调用者来平衡堆栈，这里便使用了__cdecl调用规则。BTW，Windows系统的API函数基本上是__stdcall调用形式，只有一个API例外，那就是wsprintf，它使用__cdecl调用规则，同printf函数一样，这是由于它的参数个数是可变的缘故。
 ---------------------------------------------------------------------------*/
void main()
{
    HANDLE hHeap=GetProcessHeap();
    char *buff=HeapAlloc(hHeap,0,0x10);
    char *buff2=HeapAlloc(hHeap,0,0x10);
    HMODULE hMsvcrt=LoadLibrary("msvcrt.dll");
    printf=(void *)GetProcAddress(hMsvcrt,"printf");
    printf("0x%08x\n",hHeap);
    printf("0x%08x\n",buff);
    printf("0x%08x\n\n",buff2);
}
```

执行结果为：

```
0x00130000
0x00133100
0x00133118
```

hHeap 的值怎么和那个 buff 的值那么接近呢？其实 hHeap 这个句柄就是指向 HEAP 首部的地址。在进程的用户区存着一个叫 PEB(进程环境块) 的结构，这个结构中存放着一些有关进程的重要信息，其中在 PEB 首地址偏移 0x18 处存放的 ProcessHeap 就是进程默认堆的地址，而偏移 0x90 处存放了指向进程所有堆的地址列表的指针。

windows 有很多 API 都使用进程的默认堆来存放动态数据，如 windows 2000 下的所有 ANSI 版本的函数都是在默认堆中申请内存来转换 ANSI 字符串到 Unicode 字符串的。对一个堆的访问是顺序进行的，同一时刻只能有一个线程访问堆中的数据，当多个线程同时有访问要求时，只能排队等待，这样便造成程序执行效率下降。

最后来说说内存中的`数据对齐`。_所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍_，DWORD 数据的内存起始地址能被 4 除尽，WORD 数据的内存起始地址能被 2 除尽，x86 CPU 能直接访问对齐的数据，当他试图访问一个未对齐的数据时，会在内部进行一系列的调整，这些调整对于程序来说是透明的，但是会降低运行速度，所以编译器在编译程序时会尽量保证数据对齐。

同样一段代码，我们来看看用 VC、Dev-C++ 和 lcc 三个不同编译器编译出来的程序的执行结果：

```
＃include <stdio.h>

int main()
    {
    int a;
    char b;
    int c;
    printf("0x%08x\n",&a);
    printf("0x%08x\n",&b);
    printf("0x%08x\n",&c);
    return 0;
}
```

这是用 VC 编译后的执行结果：

```
0x0012ff7c
0x0012ff7b
0x0012ff80
```

变量在内存中的顺序：b(1 字节)-a(4 字节)-c(4 字节)。

这是用 Dev-C++ 编译后的执行结果：

```
0x0022ff7c
0x0022ff7b
0x0022ff74
```

变量在内存中的顺序：c(4 字节)- 中间相隔 3 字节 - b(占 1 字节)-a(4 字节)。

这是用 lcc 编译后的执行结果：

```
0x0012ff6c
0x0012ff6b
0x0012ff64
```

变量在内存中的顺序：同上。

三个编译器都做到了数据对齐，但是后两个编译器显然没 VC“聪明”，让一个 char 占了 4 字节，浪费内存哦。

```
基础知识：
堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称
```

> 来源：yingms
> 
> https://blog.csdn.net/yingms/article/details/53188974

- EOF -

推荐阅读  点击标题可跳转

1、[C++ 堆栈工作机制](http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651160233&idx=1&sn=4846a02463a13b357562161df4e1a886&chksm=8064aff6b71326e0e53cce62bd8394dd2548a8c9a5a7bb5bf8420793cba6a808af7d5fe1d523&scene=21#wechat_redirect)

2、[Linux 字节对齐的那些事](http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651163769&idx=1&sn=53e2073fde4e550b8ea51cc72fd2d827&chksm=80645d26b713d43001ed4e44fe2634b0726f102937186d8d35786c6d0dc503fbd398b9f19553&scene=21#wechat_redirect)

3、[C++ 代码简化之道](http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651163756&idx=1&sn=001c0829f32dbe5108e196a22892c953&chksm=80645d33b713d425db465faaa88d90bdb39cba9ce6ef475ad52f622c4c35214a8ec56cf33e0a&scene=21#wechat_redirect)