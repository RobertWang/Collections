> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/145076780)

MCU 是 Microcontroller Unit 的简称，中文叫微控制器，俗称单片机，是把 CPU 的频率与规格做适当缩减，并将内存、计数器、USB、A/D 转换、UART、PLC、DMA 等周边接口，甚至 LCD 驱动电路都整合在单一芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制，诸如手机、PC 外围、遥控器，至汽车电子、工业上的步进马达、机器手臂的控制等，都可见到 MCU 的身影。

一、单片机发展简史

单片机出现的历史并不长，但发展十分迅猛。它的产生与发展和微处理器（CPU）的产生与发展大体同步，自 1971 年美国英特尔公司首先推出 4 位微处理器以来，它的发展到目前为止大致可分为 5 个阶段。下面以英特尔公司的单片机发展为代表加以介绍。

1971 年~ 1976 年

单片机发展的初级阶段。1971 年 11 月英特尔公司首先设计出集成度为 2000 只晶体管 / 片的 4 位微处理器英特尔 4004，并配有 RAM、 ROM 和移位寄存器， 构成了第一台 MCS—4 微处理器， 而后又推出了 8 位微处理器英特尔 8008， 以及其它各公司相继推出的 8 位微处理器。

1976 年~ 1980 年

低性能单片机阶段。以 1976 年英特尔公司推出的 MCS—48 系列为代表， 采用将 8 位 CPU、 8 位并行 I/O 接口、8 位定时 / 计数器、RAM 和 ROM 等集成于一块半导体芯片上的单片结构， 虽然其寻址范围有限（不大于 4 KB）， 也没有串行 I/O， RAM、 ROM 容量小， 中断系统也较简单， 但功能可满足一般工业控制和智能化仪器、仪表等的需要。

1980 年~ 1983 年

高性能单片机阶段。这一阶段推出的高性能 8 位单片机普遍带有串行口，有多级中断处理系统， 多个 16 位定时器 / 计数器。片内 RAM、 ROM 的容量加大，且寻址范围可达 64 KB，个别片内还带有 A/D 转换接口。

1983 年~ 80 年代末

16 位单片机阶段。1983 年英特尔公司又推出了高性能的 16 位单片机 MCS－96 系列，由于其采用了最新的制造工艺， 使芯片集成度高达 12 万只晶体管 / 片。

1990 年代

单片机在集成度、功能、速度、可靠性、应用领域等全方位向更高水平发展。

二、单片机的分类及应用

MCU 按其存储器类型可分为无片内 ROM 型和带片内 ROM 型两种。对于无片内 ROM 型的芯片，必须外接 EPROM 才能应用（典型为 8031）；带片内 ROM 型的芯片又分为片内 EPROM 型（典型芯片为 87C51）、MASK 片内掩模 ROM 型（典型芯片为 8051）、片内 Flash 型（典型芯片为 89C51）等类型。

按用途可分为通用型和专用型；根据数据总线的宽度和一次可处理的数据字节长度可分为 8、16、32 位 MCU。

目前，国内 MCU 应用市场最广泛的是消费电子领域，其次是工业领域、和汽车电子市场。消费电子包括家用电器、电视、游戏机和音视频系统等。工业领域包括智能家居、自动化、医疗应用及新能源生成与分配等。汽车领域包括汽车动力总成和安全控制系统等。

三、单片机的基本功能

对于绝大多数 MCU，下列功能是最普遍也是最基本的，针对不同的 MCU，其描述的方式可能会有区别，但本质上是基本相同的：

1、TImer(定时器)：TImer 的种类虽然比较多，但可归纳为两大类：一类是固定时间间隔的 TImer，即其定时的时间是由系统设定的，用户程序不可控制，系统只提供几种固定的时间间隔给用户程序进行选择，如 32Hz，16Hz，8Hz 等，此类 TImer 在 4 位 MCU 中比较常见，因此可以用来实现时钟、计时等相关的功能。

另一类则是 Programmable Timer(可编程定时器)，顾名思义，该类 Timer 的定时时间是可以由用户的程序来控制的，控制的方式包括：时钟源的选择、分频数 (Prescale) 选择及预制数的设定等，有的 MCU 三者都同时具备，而有的则可能是其中的一种或两种。此类 Timer 应用非常灵活，实际的使用也千变万化，其中最常见的一种应用就是用其实现 PWM 输出。

由于时钟源可以自由选择，因此，此类 Timer 一般均与 Event Counter(事件计数器) 合在一起。

2、IO 口：任何 MCU 都具有一定数量的 IO 口，没有 IO 口，MCU 就失去了与外部沟通的渠道。根据 IO 口的可配置情况，可以分为如下几种类型：

纯输入或纯输出口：此类 IO 口由 MCU 硬件设计决定，只能是输入或输出，不可用软件来进行实时的设定。

直接读写 IO 口：如 MCS-51 的 IO 口就属于此类 IO 口。当执行读 IO 口指令时，就是输入口; 当执行写 IO 口指令则自动为输出口。

程序编程设定输入输出方向的：此类 IO 口的输入或输出由程序根据实际的需要来进行设定，应用比较灵活，可以实现一些总线级的应用，如 I2C 总线，各种 LCD、LED Driver 的控制总线等。

对于 IO 口的使用，重要的一点必须牢记的是：对于输入口，必须有明确的电平信号，确保不能浮空 (可以通过增加上拉或下拉电阻来实现); 而对于输出口，其输出的状态电平必须考虑其外部的连接情况，应保证在 Standby 或静态状态下不存在拉电流或灌电流。

3、外部中断：外部中断也是绝大多数 MCU 所具有的基本功能，一般用于信号的实时触发，数据采样和状态的检测，中断的方式由上升沿、下降沿触发和电平触发几种。外部中断一般通过输入口来实现，若为 IO 口，则只有设为输入时其中断功能才会开启; 若为输出口，则外部中断功能将自动关闭 (ATMEL 的 ATiny 系列存在一些例外，输出口时也能触发中断功能)。外部中断的应用如下：

外部触发信号的检测：一种是基于实时性的要求，比如可控硅的控制，突发性信号的检测等，而另一种情况则是省电的需要。

信号频率的测量：为了保证信号不被遗漏，外部中断是最理想的选择。

数据的解码：在遥控应用领域，为了降低设计的成本，经常需要采用软件的方式来对各种编码数据进行解码，如 Manchester 和 PWM 编码的解码。

按键的检测和系统的唤醒：对于进入 Sleep 状态的 MCU，一般需要通过外部中断来进行唤醒，最基本的形式则是按键，通过按键的动作来产生电平的变化。

4、通讯接口：MCU 所提供的通讯接口一般包括 SPI 接口，UART，I2C 接口等，其分别描述如下：

SPI 接口：此类接口是绝大多数 MCU 都提供的一种最基本通讯方式，其数据传输采用同步时钟来控制，信号包括：SDI(串行数据输入)、SDO(串行数据输出)、SCLK(串行时钟) 及 Ready 信号; 有些情况下则可能没有 Ready 信号; 此类接口可以工作在 Master 方式或 Slave 方式下，通俗说法就是看谁提供时钟信号，提供时钟的一方为 Master，相反的一方则为 Slaver。

UART（Universal Asynchronous Receive Transmit）：属于最基本的一种异步传输接口，其信号线只有 Rx 和 Tx 两条，基本的数据格式为：Start Bit + Data Bit(7-bits/8-bits) + Parity Bit(Even， Odd or None) + Stop Bit(1~2Bit)。一位数据所占的时间称为 Baud Rate(波特率)。

对于大多数的 MCU 来讲，数据位的长度、数据校验方式 (奇校验、偶校验或无校验)、停止位(Stop Bit) 的长度及 Baud Rate 是可以通过程序编程进行灵活设定。此类接口最常用的方式就是与 PC 机的串口进行数据通讯。

I2C 接口：I2C 是由 Philips 开发的一种数据传输协议，同样采用 2 根信号来实现：SDAT(串行数据输入输出) 和 SCLK(串行时钟)。其最大的好处是可以在此总线上挂接多个设备，通过地址来进行识别和访问; I2C 总线的一个最大的好处就是非常方便用软件通过 IO 口来实现，其传输的数据速率完全由 SCLK 来控制，可快可慢，不像 UART 接口，有严格的速率要求。

5、Watchdog（看门狗定时器）：Watchdog 也是绝大多数 MCU 的一种基本配置 (一些 4 位 MCU 可能没有此功能)，大多数的 MCU 的 Watchdog 只能允许程序对其进行复位而不能对其关闭 (有的是在程序烧入时来设定的，如 Microchip PIC 系列 MCU)，而有的 MCU 则是通过特定的方式来决定其是否打开，如 Samsung 的 KS57 系列，只要程序访问了 Watchdog 寄存器，就自动开启且不能再被关闭。一般而言 watchdog 的复位时间是可以程序来设定的。Watchdog 的最基本的应用是为 MCU 因为意外的故障而导致死机提供了一种自我恢复的能力。

四、全球主流单片机制造商

（排名不分先后，整理为主流厂商，如有缺少请在评论区补充）

欧美地区

1、Freescale+NXP（飞思卡尔 + 恩智浦）：荷兰，主要提供 16 位、32 位 MCU。应用范围：汽车电子、LED 和普通照明、医疗保健、多媒体融合、家电和电动工具、楼宇自动化技术电机控制、电源和功率转换器、能源和智能电网、自动化、计算机与通信基础设施。

2、Microchip+Atmel（微芯科技 + 爱特梅尔）：美国，主要提供 16 位、32 位 MCU。应用范围：汽车电子、工业用、电机控制、汽车、楼宇自动化、家用电器、家庭娱乐、工业自动化、照明、物联网、智能能源、移动电子设备、计算机外设。

3、Cypress+Spansion（赛普拉斯 + 飞索半导体）：美国，主要提供 8 位、16 位、32 位 MCU。应用范围：汽车电子、家用电器、医疗、消费类电子、通信与电信、工业、无线。

5、Infineon（英飞凌）：德国，主要提供 16 位、32 位 MCU。应用范围：汽车电子、消费电子、工程、商用和农用车辆、数据处理、电动交通、工业应用、医疗设备、移动设备、电机控制与驱动、电源、面向摩托车电动自行车与小型电动车、智能电网、照明、太阳能系统解决方案、风能系统解决方案。

6、ST Microelectronics（意法半导体）：意大利 / 法国，主要提供 32 位 MCU。应用范围：LED 和普通照明、交通运输、医疗保健、多媒体融合、家电和电动工具、楼宇自动化技术电机控制、电源和功率转换器、能源和智能电网、自动化、计算机与通信基础设施。

7、Qualcomm（高通）：美国，主要提供 16 位，32 位 MCU。应用范围：智能手机、平板电脑、无线调制解调器。

8、Texas Instruments（德州仪器）：美国，主要提供 16 位、32 位 MCU。应用范围：汽车电子、消费电子、医疗设备、移动设备、通信。

9、Maxim（美信）：美国，主要提供 32 位 MCU。应用范围：汽车电子、消费电子、工业应用、安防。

日韩地区

1、Renesas（瑞萨）：日本，主要提供 16 位、32 位 MCU。应用范围：电脑及外设、消费类电子、健康医疗电子、汽车电子、工业、通信。

2、Toshiba（东芝）：日本，主要提供 16 位、32 位 MCU。应用范围：汽车电子、工业用、电机控制、无线通信、移动电话、电脑与周边设备、影像及音视频、消费类 (家电)、LED 照明、安全、电源管理、娱乐设备。

3、Fujitsu（富士通）：日本，主要提供 32 位 MCU。应用范围：汽车、医疗、机械，家电。

4、Samsung Electronics（三星电子）：韩国，主要提供 16 位、32 位 MCU。应用范围：汽车电子、工业用、电机控制、汽车、楼宇自动化、家用电器、家庭娱乐、工业自动化、照明、物联网、智能能源、移动电子设备、计算机外设。

中国地区

▍中国大陆地区

1、希格玛微电子：主要提供 32 位 MCU，应用范围：电信、制造、能源、交通、电力等。

2、珠海欧比特：主要提供 32 位 MCU，应用范围：航空航天：星箭站船、飞行器; 高端工控：嵌入式计算机; 舰船控制、工业控制、电力设备、环境监控。

3、兆易创新：主要提供 32 位 MCU，应用范围：工业自动化、人机界面、电机控制、安防监控、智能家居、物联网。

4、晟矽微电子：主要提供 8 位、32 位 MCU，应用范围：小家电、消费类电子、遥控器、鼠标、锂电池、数码产品、汽车电子、医疗仪器及计量、玩具、工业控制、智能家居及安防等领域。

5、芯海科技：主要提供 16、32 位 MCU，应用范围：仪器仪表、物联网、消费电子、家电、汽车电子。

6、联华集成电路：主要提供 8 位、16 位 MCU，应用范围：消费电子、白色家电、工业控制、通信设备、汽车电子、计算机。

7、珠海建荣：主要提供 8 位 MCU，应用范围：家用电器 、移动电源。

8、炬芯科技：主要提供 8 位至 32 位 MCU，应用范围：平板电脑、智能家居、多媒体、蓝牙、wifi 音频。

9、爱思科微电子：主要提供 8 位、16 位 MCU，应用范围：消费类芯片、通讯类芯片、信息类芯片、家电。

10、华芯微电子：主要提供 8 位、4 位 MCU，应用范围：卫星接收器、手机充电器、万年历、多合一遥控器。

11、上海贝岭（华大半导体控股）：主要提供 8 位、16 位、32 位 MCU，应用范围：计算机周边、HDTV、电源管理、小家电、数字家电。

12、海尔集成电路：主要提供 14 位、15 位、16 位 MCU，应用范围：消费电子、汽车电子、工业、智能仪表。

13、北京君正：主要提供 32 位 MCU，应用范围：可穿戴式设备、物联网、智能家电、汽车、消费类电子、平板电脑。

14、中微半导体：主要提供 8 位 MCU，应用范围：智能家电、汽车电子、安防监控、LED 照明及景观、智能玩具、智能家居、消费类电子。

15、神州龙芯集成电路：主要提供 32 位 MCU，应用范围：电力监控、智能电网、工业数字控制、物联网、智能家居、数据监控。

16、紫光微电子：主要提供 8 位、16 位 MCU，应用范围：智能家电。

17、时代民芯：主要提供 32 位 MCU，应用范围：汽车导航、交通监控、渔船监管、电力电信网络。

18、华润矽科微电子（华润微旗下公司）：主要提供 8 位、16 位 MCU，应用范围：消费电子、工业控制、家电。

19、国芯科技：主要提供 32 位 MCU，应用范围：信息安全领域 、办公自动化领域、通讯网络领域、 信息安全领域。

20、中天微：主要提供 32 位 MCU，应用范围：智能手机、数字电视、机顶盒、汽车电子、GPS、电子阅读器、打印机。

21、华润微电子：主要提供 8 位、16 位 MCU，应用范围：家电，消费类电子、工业自动化控制的通用控制电路。

22、中颖电子：主要提供 4 位、8 位、16 位、32 位 MCU，应用范围：家电、电机。

23、灵动微电子：主要提供 32 位，应用范围：电机控制、蓝牙控制、高清显示、无线充、无人机、微型打印机、智能标签、电子烟、LED 点阵屏等。

24、新唐科技：主要提供 8 位 MCU，应用范围：照明、物联网等。

25、东软载波：主要提供 8 位、32 位 MCU，应用范围：家电、智能家居、仪器仪表、液晶面板控制器、工业控制等。

26、贝特莱：主要提供 32 位 MCU，应用范围：智能家居、工业控制以及消费类产品领域。

27、笙泉科技：主要提供 8 位 MCU，应用范围：车用、教育、工控、医疗等中小型显示面板。

28、航顺芯片：主要提供 8 位、32 位 MCU，应用范围：汽车、物联网等。

29、复旦微电子：主要提供 16 位、32 位 MCU，应用范围：智能电表、智能门锁等。

30、华大半导体：主要提供 8 位、16 位、32 位 MCU，应用范围：工业控制、智能制造、智慧生活及物联网等。

▍中国台湾地区

1、宏晶科技：主要提供 32 位 MCU。应用范围：通信、工业控制、信息家电、语音。

2、盛群半导体：主要提供 8 位、32 位 MCU。应用范围：消费电子、LED 照明等。

3、凌阳科技：主要提供 8 位、16 位 MCU。应用范围：家庭影音。

4、中颖电子：主要提供 4 位、8 位 MCU。应用范围：充电器、移动电源、家电、工业控制。

5、松翰科技：主要提供 8 位、32 位 MCU。应用范围：摇控器、智能型充电器、大小系统、电子秤、耳温枪、血压计、胎压计、各类量测及健康器材。

6、华邦电子：主要提供 8 位、16 位 MCU。应用范围：车用电子、工业电子、网络、计算机、消费电子、物联网。

7、十速科技：主要提供 4 位、8 位、51 位 MCU。应用范围：遥控器、小家电。

8、佑华微电子：主要提供 4 位、8 位 MCU。应用范围：录音集成电路产品、消费电子、家用产品。

9、应广科技单片机：主要提供 4 位、8 位 MCU。应用范围：机械、自动化、家电、机器人。

10、义隆电子：主要提供 8 位、16 位 MCU。应用范围：消费电子、电脑、智能手机。

五、单片机的学习窍门

任何一款 MCU，其基本原理和功能都是大同小异，所不同的只是其外围功能模块的配置及数量、指令系统等。

对于指令系统，虽然形式上看似千差万别，但实际上只是符号的不同，其所代表的含义、所要完成的功能和寻址方式基本上是类似的。

要了解一款 MCU，首先需要知道就是其 ROM 空间、RAM 空间、IO 口数量、定时器数量和定时方式、所提供的外围功能模块（Peripheral Circuit）、中断源、工作电压及功耗等等。

了解这些 MCU Features 后，接下来第一步就是将所选 MCU 的功能与实际项目开发的要求的功能进行对比，明确哪些资源是目前所需要的，哪些是本项目所用不到的。

对于项目中需要用到的而所选 MCU 不提供的功能，则需要认真理解 MCU 的相关资料，以求用间接的方法来实现，例如，所开发的项目需要与 PC 机 COM 口进行通讯，而所选的 MCU 不提供 UART 口，则可以考虑用外部中断的方式来实现。

对于项目开发需要用到的资源，则需要对其 Manua * 进行认真的理解和阅读，而对于不需要的功能模块则可以忽略或浏览即可。对于 MCU 学习来讲，应用才是关键，也是最主要的目的。

明确了 MCU 的相关功能后，接下来就可以开始编程了。

对于初学者或初次使用此款 MCU 的设计者来说，可能会遇到很多对 MCU 的功能描述不明确的地方，对于此类问题，可以通过两种方法来解决，一种是编写特别的验证程序来理解资料所述的功能; 另一种则可以暂时忽略，单片机程序设计中则按照自己目前的理解来编写，留到调试时去修改和完善。前一种方法适用于时间较宽松的项目和初学者，而后一种方法则适合于具有一定单片机开发经验的人或项目进度较紧迫的情况。

指令系统千万不要特别花时间去理解。指令系统只是一种逻辑描述的符号，只有在编程时根据自己的逻辑和程序的逻辑要求来查看相关的指令即可，而且随着编程的进行，对指令系统也会越来越熟练，甚至可以不自觉地记忆下来。

六、单片机的程序编写

MCU 的程序的编写与 PC 下的程序的编写存在很大的区别，虽然现在基于 C 的 MCU 开发工具越来越流行，但对于一个高效的程序代码和喜欢使用汇编的设计者来讲，汇编语言仍然是最简洁、最有效的编程语言。

对于 MCU 的程序编写，其基本的框架可以说是大体一致的，一般分为初始化部分 (这是 MCU 程序设计与 PC 最大的不同)，主程序循环体和中断处理程序三大部分，其分别说明如下：

1、初始化：对于所有的 MCU 程序的设计来讲，初始化是最基本也是最重要的一步，一般包括如下内容：

屏蔽所有中断并初始化堆栈指针：初始化部分一般不希望有任何中断发生。

清除系统的 RAM 区域和显示 Memory：虽然有时可能没有完全的必要，但从可靠性及一致性的角度出发，特别是对于防止意外的错误，还是建议养成良好的编程习惯。

IO 口的初始化：根据项目的应用的要求，设定相关 IO 口的输入输出方式，对于输入口，需要设定其上拉或下拉电阻; 对于输出口，则必须设定其初始的电平输出，以防出现不必要的错误。

中断的设置：对于所有项目需要用到的中断源，应该给予开启并设定中断的触发条件，而对于不使用的多余的中断，则必须给予关闭。

其他功能模块的初始化：对于所有需要用到的 MCU 的外围功能模块，必须按项目的应用的要求进行相应的设置，如 UART 的通讯，需要设定 Baud Rate，数据长度，校验方式和 Stop Bit 的长度等，而对于 Programmer Timer，则必须设置其时钟源，分频数及 Reload Data 等。

参数的初始化：完成了 MCU 的硬件和资源的初始化后，接下来就是对程序中使用到的一些变量和数据的初始化设置，这一部分的初始化需要根据具体的项目及程序的总体安排来设计。对于一些用 EEPROM 来保存项目预制数的应用来讲，建议在初始化时将相关的数据拷贝到 MCU 的 RAM，以提高程序对数据的访问速度，同时降低系统的功耗（原则上，访问外部 EEPROM 都会增加电源的功耗）。

2、主程序循环体：大多数 MCU 是属于长时间不间断运行的，因此其主程序体基本上都是以循环的方式来设计，对于存在多种工作模式的应用来讲，则可能存在多个循环体，相互之间通过状态标志来进行转换。对于主程序体，一般情况下主要安排如下的模块：

计算程序：计算程序一般比较耗时，因此坚决反对放在任何中断中处理，特别是乘除法运算。

实时性要求不高或没有实时性要求的处理程序；

显示传输程序：主要针对存在外部 LED、LCD Driver 的应用。

3、中断处理程序：中断程序主要用于处理实时性要求较高的任务和事件，如，外部突发性信号的检测，按键的检测和处理，定时计数，LED 显示扫描等。

一般情况下，中断程序应尽可能保证代码的简洁和短小，对于不需要实时去处理的功能，可以在中断中设置触发的标志，然后由主程序来执行具体的事务――这一点非常重要，特别是对于低功耗、低速的 MCU 来讲，必须保证所有中断的及时响应。

4、对于不同任务体的安排，不同的 MCU 其处理的方法也有所不同：

例如，对于低速、低功耗的 MCU(Fosc=32768Hz) 应用，考虑到此类项目均为手持式设备和采用普通的 LCD 显示，对按键的反应和显示的反应要求实时性较高，因此一般采用定时中断的方式来处理按键的动作和数据的显示；而对于高速的 MCU，如 Fosc》1MHz 的应用，由于此时 MCU 有足够的时间来执行主程序循环体，因此可以只在相应的中断中设置各种触发标志，并将所有的任务放在主程序体中来执行。

5、在 MCU 的程序设计中，还需要特别注意的一点就是：

要防止在中断和主程序体中同时访问或设置同一个变量或数据的情况。有效的预防方法是，将此类数据的处理安排在一个模块中，通过判断触发标志来决定是否执行该数据的相关操作；而在其他的程序体中 (主要是中断)，对需要进行该数据的处理的地方只设置触发的标志。――这可以保证数据的执行是可预知和唯一的。

七、工程师对单片机编程的总结

1、要养成总结的好习惯，总结不仅是对自己学习的一个总结，还是对学习过程的一个回顾与加深，还可避免第二次犯错。

2、编写程序之前先要有一个对该项目熟悉的了解，做到心中有数，列一个大致框架。仔细推敲该怎么布局，怎样布局最合理，该步骤很重要。要分析先做哪个模块，具体到该模块的具体步骤，各个函数怎么命名，与其他模块的衔接等。最好拿张纸记下重要过程。

3、对于 c 语言的模块化编程，要先分好各个模块，一个模块一个模块的编程，确定一个顺序，按顺序来，该模块成功之后再编写下一个。对于头文件，当该模块编写好之后再编写该模块的头文件。

4、出现警告不要忽视，说明该程序一定有不合理之处，要弄清其来源，找到解决办法。找来源时要有针对性，可上网搜一下该方面的资料，或向别人请教。例如，居然把另一个工程内的 main 函数加入了这个工程。还有居然函数命名重复。还有根据实验现象分析原因，层层递进。还有端口定义时居然选错了接口。有时，实在解决不了就休息一下，在想也挺好的。再简单的地方也要注意一下，都有可能出错。

在单片机应用开发中，代码的使用效率问题、单片机抗干扰性和可靠性等问题仍困扰着。现归纳出单片机开发中应掌握的几个基本技巧。

八、单片机开发技巧

1、如何减少程序中的 bug

对于如何减少程序的 bug，应该先考虑系统运行中应考虑的超范围管理参数如下。

物理参数：这些参数主要是系统的输入参数，它包括激励参数、采集处理中的运行参数和处理结束的结果参数。

资源参数：这些参数主要是系统中的电路、器件、功能单元的资源，如记忆体容量、存储单元长度、堆叠深度。

应用参数：这些应用参数常表现为一些单片机、功能单元的应用条件。过程参数：指系统运行中的有序变化的参数。

2、如何提高 C 语言编程代码的效率

用 C 语言进行单片机程序设计是单片机开发与应用的必然趋势。如果使用 C 编程时，要达到最高的效率，最好熟悉所使用的 C 编译器。先试验一下每条 C 语言编译以后对应的汇编语言的语句行数，这样就可以很明确的知道效率。在今后编程的时候，使用编译效率最高的语句。各家的 C 编译器都会有一定的差异，故编译效率也会有所不同，优秀的嵌入式系统 C 编译器代码长度和执行时间仅比以汇编语言编写的同样功能程度长 5-20%。

对于复杂而开发时间紧的项目时，可以采用 C 语言，但前提是要求你对该 MCU 系统的 C 语言和 C 编译器非常熟悉，特别要注意该 C 编译系统所能支持的数据类型和算法。虽然 C 语言是最普遍的一种高级语言，但由于不同的 MCU 厂家其 C 语言编译系统是有所差别的，特别是在一些特殊功能模块的操作上。所以如果对这些特性不了解，那么调试起来问题就会很多，反而导致执行效率低于汇编语言。

3、如何解决单片机的抗干扰性问题

防止干扰最有效的方法是去除干扰源、隔断干扰路径，但往往很难做到，所以只能看单片机抗干扰能力够不够强了。在提高硬件系统抗干扰能力的同时，软件抗干扰以其设计灵活、节省硬件资源、可靠性好越来越受到重视。

单片机干扰最常见的现象就是复位，至于程序跑飞，其实也可以用软件陷阱和看门狗将程序拉回到复位状态，所以单片机软件抗干扰最重要的是处理好复位状态。

一般单片机都会有一些标志寄存器，可以用来判断复位原因；另外你也可以自己在 RAM 中埋一些标志。在每次程序复位时，通过判断这些标志，可以判断出不同的复位原因；还可以根据不同的标志直接跳到相应的程序。这样可以使程序运行有连续性，用户在使用时也不会察觉到程序被重新复位过。

4、如何测试单片机系统的可靠性

当一个单片机系统设计完成，对于不同的单片机系统产品会有不同的测试项目和方法，但是有一些是必须测试的：

测试单片机软件功能的完善性

上电、掉电测试

老化测试

ESD 和 EFT 等测试

有时候，我们还可以模拟人为使用中，可能发生的破坏情况。例如用人体或者衣服织物故意摩擦单片机系统的接触端口，由此测试抗静电的能力。用大功率电钻靠近单片机系统工作，由此测试抗电磁干扰能力等。

综上所述，单片机已成为计算机发展和应用的一个重要方面，单片机应用的重要意义还在于，它从根本上改变了传统的控制系统设计思想和设计方法。

从前必须由模拟电路或数字电路实现的大部分功能，现在已能用单片机通过软件方法来实现了。这种软件代替硬件的控制技术也称为微控制技术，是传统控制技术的一次革命。

此外在开发和应用过程中我们更要掌握技巧，提高效率，以便于发挥它更加广阔的用途。

九、芯片操作总结

对芯片的操作主要是对芯片内寄存器的操作，芯片内寄存器在存储器上映射的都有自己的唯一地址，这也就是对相应的地址的操作。看芯片，首先看时序图，再了解相应的寄存器，了解是如何操作的，定义需要的端口（程序可以识别），编写写操作程序和读操作程序。

如何往芯片内写入数据，如何读出数据，通过哪个端口输入或读出（最主要的地方）。

通过总线连接芯片时，首先要了解该总线的协议。I2c 总线连接的芯片，主要通过该总线去控制该芯片。

1、点阵中一个 74hc595 用于列的选择，令外两个用于颜色的选择，点阵相当于二极管的集合，

一端给高电平，另一端给低电平，二极管才能亮。只是一端选择不同时，亮不同的颜色。

定时器工作模式的选择：高四位是设置定时器 T1，低四位设置 T0。然后各模式的后两位设置工作模式。当设置两个定时器时，注意使用或（|）。当用中断时，注意进入中断后，该清零的要清零。

2、串口收发：波特率的设置一般用模式 2（自动重装初值），因为不同的装置，处理数据的能力不同，设置波特率主要为了照顾低速装置及为了彼此间的通讯。中断标志位要软件清零。设置串口中断时，收发无论哪一个产生都能进入中断函数，因此要注意设置中断函数。（自我感觉一般设置一种功能，当做上位机或下位机）。

发送用中断的话，要解决第一次该怎么进入中断，因此首先要发送一次，此后就可以进入中断了。一次只能发一字节，而且只有在 TI 置一之后才能发送下一位。

3、Pcf8591ad 转换，有四个通道的输入，读 pcf8591 时，选通哪一个通道，读的就是那个通道输入的电压，转换后的数据存储在该芯片内，再读出。读时先写芯片的地址，在写器件的子地址（0x40 | 通道号），然后就是读出的数据。

4、Da 转换是先向芯片内写入器件地址，在写子地址（0x40），在写要转换的数字量。器件地址芯片资料有介绍。

5、对于液晶显示，写入数据显示后，他会一直显示，不用持续刷新，要想改变，只有重新输入。

6、对于 ds1302 时钟芯片，读数据时是在写入数据时的第八个时钟下降沿就读出第一位数据的的，然后再为下次输出做准备，注意程序的写法，还要注意返回值放的位置。

7、Ds1302 中先指明寄存器，再向其中写入数据。芯片资料上的寄存器标出的是地址。（写保护处程序还不大明白，不是一直都有写入吗？为什么还打开写保护？）

（根据前面的大侠，可以在初始化时间后设一标志，有此标志则不用再初始化时间。但是如果断电后，MCU 的 RAM 是无法保存这个标志的，因此可以用 DS1302 的 RAM 保存该标志，待上电后读取该标志。我也是初学者，最近也打算用 DS1302。不知说法对不，我也还没具体实施，多交流）

8、初始化最好还要写一下，以防以后忘记。有时注意读出或写入时，首先操作的是最低位还是最高位，可根据时序图判断出。

9、对于红外收发，接收时，他是根据两个下降沿之间的时间长短来确定是高电平还是低电平，写程序时，先用定时器确定时间长短，保存，然后再转化成二进制（该程序写法多看看，很好）。

10、步进电机：主要做开关用，步进电机的力矩随转速的升高而降低。主要用在机床上零部件加工的自动进给。对有较高精度的控制场所都可也使用。

步进电机是将电脉冲信号转变为角位移或线位移的开环控制元步进电机件。在非超载的情况下，电机的转速、停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度，称为 “步距角”，它的旋转是以固定的角度一步一步运行的。可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。

11、伺服电机：（servo motor ）是指在伺服系统中控制机械元件运转的发动机，是一种补助马达间接变速装置。伺服电机可使控制速度，位置精度非常准确，可以将电压信号转化为转矩和转速以驱动控制对象。伺服电机转子转速受输入信号控制，并能快速反应，在自动控制系统中，用作执行元件，且具有机电时间常数小、线性度高、始动电压等特性，可把所收到的电信号转换成电动机轴上的角位移或角速度输出。分为直流和交流伺服电动机两大类，其主要特点是，当信号电压为零时无自转现象，转速随着转矩的增加而匀速下降。

直流电机：范围较大，小车上都是。

12、汉字概览：

为了将汉字在显示器或打印机上输出，把汉字按图形符号设计成点阵图，就得到了相应的点阵代码（字形码）。

为在计算机内表示汉字而统一的编码方式形成汉字编码叫内码（如国标码），内码是惟一的（相当于该字的身份证号）。为方便汉字输入而形成的汉字编码为输入码，属于汉字的外码，输入码因编码方式不同而不同，是多种多样的。为显示和打印输出汉字而形成的汉字编码为字形码，计算机通过汉字内码在字模库中找出汉字的字形码，实现其转换。

机内码

根据国标码的规定，每一个汉字都有了确定的二进制代码，但是这个代码在计算机内部处理时会与 ASCII 码发生冲突，为解决这个问题，把国标码的每一个字节的首位上加 1。由于 ASCII 码只用 7 位，所以，这个首位上的 “1” 就可以作为识别汉字代码的标志，计算机在处理到首位是 “1” 的代码时把它理解为是汉字的信息，在处理到首位是 “0” 的代码时把它理解为是 ASCII 码。经过这样处理后的国标码（内码）就是机内码。

如果我们把这个 “口” 字图形的 “.” 处用 “0” 代替，就可以很形象地得到 “口” 的字形码: 0000H 0004H 3FFAH 2004H 2004H 2004H 2004H 2004H 2004H 2004H 2004H2004H 3FFAH 2004H 0000H 0000H。计算机要输出 “口” 时，先找到显示字库的首址，根据 “口” 的机内码经过计算，再去找到 “口” 的字形码，然后根据字形码 (要用二进制) 通过字符发生器的控制在屏幕上进行依次扫描，其中二进制代码中是 “0” 的地方空扫，是 “1” 的地方扫出亮点，于是就可以得到 “口” 的字符图形。

汉字字模按国标码的顺序排列，以二进制文件形式存放在存储器中, 构成汉字字模字库, 亦称为汉字字形库, 称汉字库

两种编码方法，见头文件

GB1616.h//------------------ 汉字字模的数据结构定义 ------------------------//

struct typFNT_GB16 // 汉字字模数据结构

{

unsignedchar Index[3]; // 汉字内码索引

unsignedchar Msk[32]; // 点阵码数据

};

/////////////////////////////////////////////////////////////////////////

// 汉字字模表 //

// 汉字库: [宋体 16.dot](https://link.zhihu.com/?target=http%3A//%25E5%25AE%258B%25E4%25BD%259316.dot), 横向取模左高位, 数据排列: 从左到右从上到下 //

/////////////////////////////////////////////////////////////////////////

conststruct typFNT_GB16 codeGB_16[]= // 数据表

{

/------------------------------------------------------------------------------

; 源文件 / 文字 : 徐

; 宽 × 高（像素）:16×16

------------------------------------------------------------------------------/

“徐”,0x10,0x80,0x10,0x80,0x21,0x40,0x42,0x20,0x94,0x10,0x1B,0xEC,0x20,0x80,0x60,0x80,

0xAF,0xF8,0x20,0x80,0x22,0xA0,0x24,0x90,0x2A,0x88,0x21,0x00,0x00,0x00,0x00,0x00,

这个结构，很简单的：一个是内码，一个点阵序列，以前的点阵库是按内码顺序放的，不需要内码索引的，如果只放部分汉字，就需要内码索引了。（前面的汉字 “徐” 是为了要输出 “徐” 的时候找到该字的点阵序列，这个点阵序列是自己写的，当用 1602 显示时，因为该芯片内存在英文的点阵序列，所以就不用写了）一般内码两个字节就行了，多用 1 个字节是加了个尾 0 而已，这样，汉字内码处直接放汉字字符串就可；

codeGB_16[k].Index[0]

codeGB_16[k] 说明有一个结构体 typFNT_GB16 的数组叫做 codeGB_16

codeGB_16[k] 是数组中第 k+1 个成员

index 是结构体 typFNT_GB16 的成员，所以可以用 codeGB_16[k].Index 来进行引用

同时 index 又是个数组，所以可以 index[0]

if((codeGB_16[k].Index[0]==c[0])&&(codeGB_16[k].Index[1]==c[1]))

&& 是 逻辑与运算符

意思是 && 符号的两边的值都为真 && 的值才为真，也就是 true && true =true

这句的意思是

codeGB_16[k].Index[0]==c[0] 和 codeGB_16[k].Index[1]==c[1] 同时成立

if 下面的语句才执行

codeGB_16[] 是个结构体数组，codeGB_16[k].Index[0] 是说结构体数组的第 K 个结构体的 index 成员的第 0 个元素值。

13、12864 液晶：

每个显示点对应一位二进制数，1 表示亮，0 表示灭。存储这些点阵信息的 RAM 称为显示数据存储器。要显示某个图形或汉字就是将相应的点阵信息写入到相应的存储单元中。

绘图 RAM 的地址计数器（AC）只会对水平地址 (X 轴) 自动加一, 当水平地址 = 0FH 时会重新设为 00H 但并不会对垂直地址做进位自动加一，故当连续写入多笔资料时，程序需自行判断垂直地址是否需重新设定

14、绘图 RAM（GDRAM）

绘图显示 RAM 提供 128×8 个字节的记忆空间，在更改绘图 RAM 时，先连续写入水平与垂直的坐标值，再写入两个字节的数据到绘图 RAM，而地址计数器（AC）会对水平地址（X 地址）自动加一，当水平地址为 0XFH 时会重新设为 00H ；不会对垂直地址做进位自动加 1. 。在写入绘图 RAM 的期间，绘图显示必须关闭，

[cpp] view plain copy

// 显示汉字

voiddispString (uchar X, Y,uchar *msg) //X 为哪一行，Y 为哪一列。msg

为汉字

{

if(X0) X = 0x80; // 第一行，汉字显示坐标

else if(X1) X = 0x90; // 第二行

else if(X==2) X = 0x88; // 第三行

else X = 0x98; // 第四行

Y = X + Y; //Y 为 1 往右移一位

write_com(Y); // 写入坐标

while (*msg)

{

write_data(*msg++); // 显示汉字

}

}

//////////////////////////////// //////////////// ///////////////

// 显示图象

voiddisppicture(uchar code *adder)

{

uint i,j;

//******* 显示上半屏内容设置

for(i=0;i<32;i++) // 上半屏 32 个列地址

{

write_com(0x80 + i); //SET 垂直地址 VERTICALADD

write_com(0x80); //SET 水平地址 HORIZONTAL ADD

for(j=0;j<16;j++)

{

write_data(*adder);

adder++;

}

}

//******* 显示下半屏内容设置

for(i=0;i<32;i++) //

{

write_com(0x80 + i); //SET 垂直地址 VERTICALADD

write_com(0x88); //SET 水平地址 HORIZONTAL ADD

for(j=0;j<16;j++)

{

write_data(*adder);

adder++;

}

}

}

对于 C 语言，定义的变量，自动为其分配空间，其地址为该变量的名称。通过该名称，可以在内存中招到该数据，经过运算得到新数据，而汇编中需要编程者自己定义存储空间及把数据送到累加器等进行运算，每一步都需要编程者操作。而 C 语言这些过程由编译器去完成。

15、一些有用的答疑解惑

①、单片机 C 语言，其变量的内存开辟是如何进行的？难道是编译器，在编译过程中智能地加入分配与回收的代码？关键之处在于我所做的程序，如何保证其没有内存溢出错误？如果我进行的是递归运算，这样的话，内存需求是很难自己计算的。

②、单片机 C 语言在变量定义上是否会受到约束？比如浮点型数据的乘除运算，通过汇编还写，代码相当复杂，如果直接 C 语言来写，岂不过份简单？

③、单片机 C 语言生成的 hex 文件中，指令及数据的 ROM 的地址分布是否编译器自动分配？可否用户进行分配？

回答 1：c 语言写的单片机程序，先由 1 个程序（好像是 c51.exe）编译，编译完成后，变量的存储空间大小已经安排好，只是还没分配具体地址（地址浮动），接下来有另一个程序（好像是 a51.exe）进行连接，连接以后，具体地址确定。

如果变量过多，编译会提示数据段 too large，要保证其没有内存溢出错误，主要考虑堆栈是否溢出，要靠经验

单片机 c 语言一般禁止递归，一般都避免用递归运算，单片机毕竟不是 PC，会影响速度的，要递归的话，用 DSP 芯片更合适，总之，要会挑合适的芯片

回答 2：变量的大小（位数）一般和芯片累加器的位数一样，比如 51 常用 8 位的，因为它是 8 位单片机

单片机可以定义位变量，但是不可以定义位数组。用 c 语言写只是看着简单，实际生成的代码量是最多的，用于控制的单片机几乎不用浮点数运算，不仅慢还麻烦还占地方，如果是 DSP 芯片，本身有适合的硬件结构，会好很多。

回答 3：一般是自动分配的，可以 c 语言和汇编语言混合编程，也可以用 Keil C 在线汇编，芯片与外部的数据交换都是通过端口进行的。