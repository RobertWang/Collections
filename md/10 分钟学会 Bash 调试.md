> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650810451&idx=4&sn=10f6a61cb5b19262cd58e2f8131c6b4c&chksm=bd01bd1d8a76340bdb41722bcc4f64f414ca622b78137348622e29de5a2147b0bd6e7c34af72&mpshare=1&scene=1&srcid=0725TUnqg6fPlYSrWTOYVxlb&sharer_sharetime=1627209938826&sharer_shareid=7fece245937ac96f04f0fb8e1311fff1#rd)

### 调试常用选项

<table data-source-line="13" width="NaN" class=""><thead><tr data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; background-color: rgb(255, 255, 255); border-top: 1px solid rgb(198, 203, 209);"><th data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-top-width: 1px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">选项</th><th data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-top-width: 1px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">说明</th></tr></thead><tbody><tr data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; background-color: rgb(255, 255, 255); border-top: 1px solid rgb(198, 203, 209);"><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">-x</td><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">输出结果之前，先输出执行的命令</td></tr><tr data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; background-color: rgb(246, 248, 250); border-top: 1px solid rgb(198, 203, 209);"><td data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">-u</td><td data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">遇到不存在的变量就会报错，并停止执行</td></tr><tr data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; background-color: rgb(255, 255, 255); border-top: 1px solid rgb(198, 203, 209);"><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">-e</td><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">发生错误时，终止执行</td></tr><tr data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; background-color: rgb(246, 248, 250); border-top: 1px solid rgb(198, 203, 209);"><td data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">-n</td><td data-darkmode-bgcolor-16272179681827="rgb(189, 190, 192)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(246, 248, 250)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">检查语法错误</td></tr><tr data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; background-color: rgb(255, 255, 255); border-top: 1px solid rgb(198, 203, 209);"><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;">-o pipefail</td><td data-darkmode-bgcolor-16272179681827="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16272179681827="#fff|rgb(255, 255, 255)" data-style="box-sizing: border-box; padding: 6px 13px; border-color: rgb(223, 226, 229); word-break: break-all; text-align: center;" class="">管道子命令发生错误，终止执行</td></tr></tbody></table>

### 跟踪脚本的执行

*   输出调试信息
    

通常，脚本执行之后，只有结果输出，当运行多条命令的时候，就会连续输出多条结果，无法分清哪条命令对应哪条结果, 使用 `-x`选项，会先输出将要执行的那一行命令的调试信息，然后再执行命令

```
#!/bin/bash

echo "today is :"$(date +'%Y-%m-%d')
```

我们使用 `-x` 选项来执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# bash -x ta.sh 
++ date +%Y-%m-%d
+ echo 'today is :2021-07-10'
today is :2021-07-10
```

把 `-x` 选项放到 `#!/bin/bash` 语句后面，执行的时候不带 `-x` 也能实现同样的效果，上述脚本只需要把 #!/bin/bash 改成 #!/bin/bash -x 即可

*   输出行号
    

上面示例中脚本内容很少，试想下，如果脚本内容达到了几百行或者几千行之后，输出每一行命令的提示信息，阅读起来就很费劲了，在这种情况下，我们在每行输出前加上行号，可以直接定位到具体的行

修改下 `ta.sh` 脚本，修改后的内容如下

```
#!/bin/bash 

PS4='+${BASH_SOURCE}:${LINENO} '
echo "start..."
set -x
echo "today is :"$(date +'%Y-%m-%d')
set +x
echo "end..."
```

修改之后的脚本加入了 PS4 变量, 它是调试信息的前缀，默认值是 "+", 我们可以修改它的值，达到输出的调试信息中包含行号的目的

上述代码中 "${BASH_SOURCE}" 表示 当前执行的 shell 脚本的相对路径，在这里用来表示脚本文件名，"${LINENO}" 表示行号，修改 PS4 之后，输出的调试信息就会包括 脚本名字以及行号

我们执行脚本，看下结果

```
[root@VM-0-2-centos shell_debug]# bash -x ta.sh 
+ PS4='+${BASH_SOURCE}:${LINENO} '
+ta.sh:4 echo start...
start...
++ta.sh:5 date +%Y-%m-%d
+ta.sh:5 echo 'today is :2021-07-10'
today is :2021-07-10
+ta.sh:6 echo end...
end...
```

从结果可以看出，每一行命令的调试信息中都包含了文件名和行号

*   输出部分调试信息
    

有时，我们只需要输出部分调试信息，这个时候就需要我们手动去设置 `-x` 选项了，把需要输出调试信息的命令放到 `set -x` 和`set +x` 之间

修改下 `ta.sh` 脚本，内容如下

```
#!/bin/bash

echo "test..."

set -x
echo "today is :"$(date +'%Y-%m-%d')
set +x

echo "finish..."
```

执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# ./ta.sh 
[root@VM-0-2-centos shell_debug]# ./ta.sh 
test...
++ date +%Y-%m-%d
+ echo 'today is :2021-07-10'
today is :2021-07-10
+ set +x
finish...
```

从结果可以看出，只有 `echo today is :"$(date +'%Y-%m-%d')` 命令输出了调试信息，`set -x` 相当于开启调试信息，`set +x` 则是关闭调试信息

这里需要注意下，脚本中使用了 `set -x` 时 , 执行的时候就不要再加 `-x` 了

### 日志打印

通过打印日志来调试 shell 脚本是常用的方式，在一行命令前后打印变量值或者命令结果，通过日志来判断是否有错误

但是，当脚本比较长的时候，需要打印的日志就有点儿多了，而且，调试完了后，这些调试日志就不再需要了，这时就要一行行的删掉日志打印

下面介绍一种方法，把脚本中所有的日志打印加一个开关，当开关打开的时候，就会输出调试相关的日志，不需要的时候，直接关闭开关即可

现有脚本 `debug1.sh`, 内容如下

```
#!/bin/bash

#调试开关, on 表示开启,其他表示关闭
IS_DEBUG="on"
#调试开关函数
function _DEBUG()
{
   [ "$IS_DEBUG" == "on" ] && $@
}

va=1
_DEBUG echo 'old value:'$va
#变量val加1
let va++
echo 'new value:'$va
```

上述脚本中，IS_DEBUG 变量是调试开关，"on" 表示开启，其他表示关闭

_DEBUG() 是调试开关函数，它的功能是：如果 IS_DEBUG 为 "on" ，执行后面的命令，否则忽略

先打开调试开关， 执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# ./debug1.sh 
old value:1
new value:2
```

再关闭调试开关，执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# ./debug1.sh 
new value:2
```

从上面两组测试结果可以看出，当打开调试开关，也即设置 IS_DEBUG="on" 后， 语句 _DEBUG echo 'old value:'$va 会执行 echo 'old value:'$va 命令，当 IS_DEBUG="off" 时, 就会忽略 echo 'old value:'$va 命令

所以，当调试的时候，打开调试开关，调试完成之后，脚本不需要做任何修改，只需要关闭开关，调试相关的命令就都不会执行了

### 常见的错误处理

*   不存在的变量
    

执行脚本的时候，遇到不存在的变量，默认会忽略它

现有脚本 `td.sh`, 内容如下

```
#!/bin/bash


echo "start..."
echo $ta
echo "end..."
```

脚本中 `ta` 是一个不存在的变量，脚本执行结果如下

```
[root@VM-0-2-centos shell_debug]# ./td.sh 
start...

end...
```

可以看到，`echo $ta` 输出了一个空行，脚本直接忽略了不存在的 `ta` 变量， 并且继续执行后面的命令

这种情况通常并不是我们希望的结果，遇到不存在的变量，应该直接报错，并停止执行后面的命令，在脚本开头加上 `set -u` 语句或者执行脚本的时候加上 `-u` ，可以得到我们期望的结果

在脚本开头加上 `set -u` 语句，整个脚本内容如下

```
#!/bin/bash

set -u
echo "start..."
echo $ta
echo "end..."
```

执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# ./td.sh 
start...
./td.sh: line 5: ta: unbound variable
```

可以看到，加了 `set -u` 语句之后，遇到不存在的变量 `ta`, 直接报错，并且停止执行后面的命令

当然，我们使用 `bash -u td.sh` 命令执行脚本也会得到相同的结果

*   语法错误
    

语法错误是 shell 脚本执行错误的原因之一，执行脚本的时候加上 `-n`, 当脚本有语法错误，不会继续执行，而是打印错误信息

现有脚本 `te.sh`, 内容如下

```
#!/bin/bash

if [ $# -le 0 ];then
   echo "no param.."
```

输入 `bash -n te.sh` 命令，并回车，结果如下

```
[root@VM-0-2-centos shell_debug]# bash -n te.sh 
te.sh: line 5: syntax error: unexpected end of file
```

上面的脚本中的 if 缺少结尾的 fi, 所以执行 `bash -n te.sh` 命令之后会出现语法错误的提示

这个选项很实用，特别是当我们写完 shell 脚本之后，不要急着执行，先使用 `-n` 选项检查下有没有语法错误，它可以帮我们提前发现错误

*   发生错误，终止执行
    

一般情况下，脚本执行时发生错误了，还是会继续执行后面的命令

现有脚本 `tf.sh`, 内容如下

```
#!/bin/bash

echo "start..."
abc
echo "end..."
```

执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# ./tf.sh 
start...
./tf.sh: line 4: abc: command not found
end...
```

从结果可以看到，脚本中第四行的 abc 是未知的命令，执行时发生了错误，但是脚本还是继续向后执行，一直到结束

这种行为不利于脚本的安全和错误排查，在实际应用中，发生了错误应该停止执行脚本，防止错误越积越多，我们可以使用 `-e` 选项来避免这个问题

加上 `-e` 选项，再次执行上述脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# bash -e ./tf.sh 
start...
./tf.sh: line 4: abc: command not found
```

从上面结果可以知道，脚本执行到第四行的时候发生了错误，此时脚本停止往下执行了

*   管道子命令失败，终止执行
    

上面提到的 `-e` 选项有个特殊的情况，不适用于管道命令，管道命令是通过管道符 "|" 组合的命令， 具体的看下面的例子吧

现有脚本 `tg.sh`, 内容如下

```
#!/bin/bash

echo "start..."
abc | echo "111"
echo "end..."
```

脚本的第四行， abc | echo "111" 是管道命令，我们执行 `bash -e ./tg.sh` 命令后，结果如下

```
[root@VM-0-2-centos shell_debug]# bash -e ./tg.sh 
start...
./tg.sh: line 4: abc: command not found
end...
```

可以看到，即使使用 `-e` 选项执行脚本，发生错误的时候，还是会继续往下执行，直到结束

我们使用 `set -o pipefail` 来解决这种情况，只要管道命令中一个子命令发生了错误, 整个管道命令就失败了，脚本就会终止执行

修改下上述脚本，内容如下

```
#!/bin/bash

set -o pipefail
echo "start..."
abc | echo "111"
echo "end..."
```

再次执行脚本，结果如下

```
[root@VM-0-2-centos shell_debug]# bash -e tg.sh 
start...
tg.sh: line 5: abc: command not found
```

可以看到，在 `tg.sh` 脚本开头加上 `set -o pipefail` 语句之后，再次执行脚本， 管道命令 abc | echo "111" 执行子命令 abc 时发生错误，后续的子命令不再执行了，整个管道命令失败了

由于执行时加了 `-e` 选项，当管道命令执行失败了，脚本就会终止执行，所以 `echo "end..."` 没有执行