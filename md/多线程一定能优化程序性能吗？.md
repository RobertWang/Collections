> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650859229&idx=2&sn=50f10871adf753eb8e0f7560732e87c9&chksm=bd0173938a76fa8529fb13205bc3595ffb8b3ad3f1afb64a0cb0c57f69bae1092ced4df6e6c4&mpshare=1&scene=1&srcid=0723TRbisNnetCnA1x8EitPn&sharer_sharetime=1658578777404&sharer_shareid=8a467675e94cd5b11b6640b7770d6cc6#rd)

_________出品 | 码农的荒岛求生 （ID：escape-it）_________

问：如果一个和尚挑水喝，两个和尚抬水喝，三个和尚没水喝，那么众人拾柴一定火焰高吗？  

计算机中的一切设计都是为了更加高效的利用硬件资源，包括：CPU、内存、IO 等，我们一样一样来了解一下。

#### 

**多线程与 CPU**

多线程与 CPU 是程序员了解的最多的，我们知道多线的目的之一在于充分利用多核，但这里有个前提就是你要处理的任务真的能拆分成独立的子任务。

![](https://mmbiz.qpic.cn/mmbiz_png/9BK2WL6kfcSstYxHzLn8OZaomfL97FTmHNia8D36cW8oyMRtClFw76vlRsgHt4Nyoeia3EnK8iaWY5gjHSWgiaF6kA/640?wx_fmt=png)

举个例子，如果你想对一个数组所有元素的和，那么这个任务就可以拆分成为两个独立的子任务：任务 A 计算前一半数组元素的和，任务 B 计算后一半数组元素的和，然后任务 A 和任务 B 分别交给两个线程来执行。

如果是在多核系统下这类多线程并行处理将显著提高程序性能，但这种使用多线程充分利用多核带来的性能提升是有上限的。

道理很简单，这就好比盖房子，盖房子算是个不大不小的工程，让一个人来完成也不是不可以，但再来六七个人显然能加快工程速度，但是再来成百上千工人来盖一栋房子可能速度反而会变慢，毕竟资源是有限的 (可用的工具等)，人一多需要用在协调上的时间就会变多，多线程也是同样的道理，当线程数量超过某个临界点时操作系统就开始忙不过来了 (频繁调度切换)，我称之为三个和尚没水喝现象。

![](https://mmbiz.qpic.cn/mmbiz_png/9BK2WL6kfcSstYxHzLn8OZaomfL97FTmjCHIS2lqH0F3z7aH1ic4zy1gNbYn7GUdWNCaZZP3QtRWs1KDLAqmsSw/640?wx_fmt=png)

但如果系统是单核的，那么这种任务拆分则不会有什么效果，因为不管你创建多少线程真正工作的 CPU 只有一个。

当然也有可能我们根本就不能对任务进行拆分，像计算斐波那契数列这类问题，如果你不能计算出 f(n-1) 与 f(n-2) 的解，那么你根本就没有办法计算出当前问题 f(n) 的解，被拆分的两个任务 A 和 B 有前后依赖关系，这时多线程就没有用武之地了。

还有一种可能，就是你的问题规模非常小，如果这个数组是有几百几千个元素，那么这时你使用多线程意义不大，这时使用多线程带来的收益不足以抵消掉多线程带来的性能开销。

##### 

**多线程与 IO**

多线程一定能提升程序的 IO 性能吗？答案显然不是的。

最简单的场景是这样的，你的程序需要从一个速度极慢的网络链接上读写数据，在这种情况下一个线程很可能就足以应付的过来，创建多个线程反而可能对程序性能有损。

相同的情况也会出现在磁盘上，一个线程可能就已经将磁盘打满，这时创建多个线程去读写文件显然不能加快程序的处理速度。

![](https://mmbiz.qpic.cn/mmbiz_png/9BK2WL6kfcQlzMIMYrr1atiay63c28h4H3ZWN0l3QkWicGxqOpbGdBV07KW1pdRQqzLRzmYDcoHribUiaIEAmVQWfQ/640?wx_fmt=png)

而在服务器端，程序员也使用多线程加快程序处理速度，在这里，一个典型的问题是阻塞式网络 IO 会导致调用线程被挂起而暂停运行，此时最简单的方法就是创建多个线程，每个线程处理一个请求，但随着请求的增多创建的线程也会越来越多，此时三个和尚没水喝现象开始出现，IO 多路复用技术可以很好的解决这一问题。

当然，如果你的场景是 IO 会阻塞住处理线程，那么此时创建两个线程，一个负责处理数据，一个负责等待 IO，那么这显然会提高程序性能。

##### 

**多线程与内存**

内存其实和磁盘一样，也是有读写带宽上限的，但我们的程序一般都不会达到内存读写带宽上限，这并不是瓶颈。

瓶颈在于多线程共享的内存资源 (数据) 以及多核系统的 cache 一致性问题。

一般来说，对于多线程共享资源通常需要互斥访问，然而为加快内存读写速度，现代处理器中都有 cache 系统 (L1、L2、L3)，每个核心都有自己的 cache，这些 cache 会缓存内存数据，也就是说一份数据可能会同时存在于内存以及各个核心的 cache 中，这就会带来经典的数据一致性问题：某个核心修改了 cache 中的数据后需要将其同步给其它核心，这就要求 cache 系统中必须有能确保一致性的协议，否则程序可能会读取到错误的(过期的) 数据。

![](https://mmbiz.qpic.cn/mmbiz_png/9BK2WL6kfcQlzMIMYrr1atiay63c28h4HS9jgbeerXcD4qiceWVfPL2jlUzVaHQgWWharM4m0iaEVA2Awlj1T6WZQ/640?wx_fmt=png)

然而这种同步是有性能损耗的，多个线程频繁操作同一个变量可能导致处理器 cache 系统需要频繁在各个核心之间进行同步，极端情况下多线程程序性能甚至比单线程要差。

因此多线程之间能不共享数据就不要共享，如果一定要共享，那么就尽量将其控制在最小范围，读写频次控制到最少。

**<END>**