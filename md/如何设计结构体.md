> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666556699&idx=3&sn=bc16a4ffe8e88581c5a08a8214d7721d&chksm=80dca9b0b7ab20a6f114a742512da062396c9cf53f0a9ea2e51a6aed4d548e420dfad25b9f2c&scene=21#wechat_redirect)

之前写过一篇《[如何设计一个 C++ 的类](http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651163033&idx=1&sn=7e6cb870defe57421d82dd974a6ac9c0&chksm=806458c6b713d1d0f63452bf8a3367778427cb45d9958707e35d006e8e7bcc13cf5faa06e8ef&scene=21#wechat_redirect)》，今天这里继续聊聊如何设计结构体，注意本文不介绍在 C++ 中结构体和类具体有什么区别，本文所说的结构体是指只有数据字段不带任何函数的那种结构体。

当创建结构体的实例时，结构体的数据成员会按其声明的顺序连续存储。然而，这个声明的顺序也是有学问的，顺序不同结构体的大小可能有很大差别，数据成员的访问性能也可能会有很大区别！

这里涉及一个概念：内存对齐。关于内存对齐我之前写过一篇文章：《[内存对齐](http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&mid=2651163632&idx=2&sn=175424d3498f61cf84ec1799d10a2a61&chksm=80645aafb713d3b9b71f21793f778b49a9c5f863ab52bcaac7e8e4470648327e2ce002396ed7&scene=21#wechat_redirect)》，这里不深入讨论，只是简单介绍一下。

大多数编译器会对齐数据成员，会以四舍五入地址方式来优化数据的访问，如下表所示。  
![](https://mmbiz.qpic.cn/mmbiz_jpg/JeibBY5FJRBFJ7HYbPGPkGVRMsPJ9kDCewDMzI17EP5PXicsNWSEDibLNleHhXWKMmlaaUrnu3XC849jxeiaSviaJfw/640?wx_fmt=jpeg)  
这种内存对齐可能会在成员大小混合的结构体中产生未使用字节的空洞。  
例如：

```
struct S {
    short int a; // 2字节
    // 6个空洞
    double b; // 8
    int d; // 4
    // 4个空洞
};
S ArrayOfStructures[100];
```

这里，在 a 和 b 之间有 6 个未使用的字节，因为 b 必须从一个能被 8 整除的地址开始。

最后还有 4 个未使用的字节空洞。这样做的原因是，数组中 S 的下一个实例必须从一个能被 8 整除的地址开始，以便将其 b 成员以 8 对齐。

然而，如果改变一下结构体中数据成员声明的顺序，通过将最小的成员放在最后，未使用的字节数可以减少到 2：

```
struct S {
    double b; // 8
    int d; // 4
    short int a; // 2
    // 2个空洞
};
S ArrayOfStructures[100];
```

这种重新排序使结构体变小了 8 个字节，那整个数组则变小了 800 个字节。

在此特性上，类和结构体相同。通过重新排序数据成员，结构体对象和类对象通常可以变得更小。如果类至少有一个虚成员函数，则在第一个数据成员之前或最后一个成员之后会有一个指向虚函数表的指针。该指针在 32 位系统中为 4 字节，在 64 位系统中为 8 字节。

如果不确定结构体或它的每个成员有多大，可以使用 sizeof 操作符进行一些测试。sizeof 操作符返回的值包括对象末尾的任何未使用的字节（内存对齐后的字节数）。

还有一个知识点：

如果数据成员相对于结构体或类开头的偏移量小于 128，则访问数据成员的代码会更加紧凑，因为该偏移量可以使用 8 位有符号的数字来表示。如果相对于结构体或类的开头的偏移量是 128 字节或更多，那么偏移量必须表示为一个 32 位数字 (指令集在 8 位到 32 位之间没有偏移量)。例如：

```
struct S {
    int a[100]; // 400
    int b; // 4
    int read() { return b; }
};
```

b 成员的偏移量是 400。任何通过指针或成员函数访问 b 字段的代码都需要将偏移量编码为 32 位数字。如果交换 a 和 b，则两者都可以通过编码为 8 位有符号数字的偏移量来访问，或者根本不需要偏移量。

这会使代码更紧凑，方便更有效地使用代码缓存。因此，建议在结构或类声明中，大数组和其他大对象排在最后，最常用的数据成员排在前面。如果不能在前 128 个字节内包含所有数据成员，则将最常用的成员放在前 128 个字节中。  
通过上面两个小知识点可以使得将结构体设计的更小，访问数据成员的速度更快，但是这有时往往会牺牲一些可读性，比如这种结构体：

```
struct S {
    int deskA;
    double deskB;
    bool deskC;
    int chairA;
    double chairB;
    bool chairC;
};
```

可能这样修改后结构体会更小：

```
struct S {
    int deskA;
    int chairA;
    double deskB;
    double chairB;
    bool deskC;
    bool chairC;
};
```

但是我们一般情况下貌似希望同类的字段放在一起，这样代码可读性更高一些，易于读懂代码。至于这种结构体具体需不需要重新排序，那就需要大家自己权衡啦。

**小总结：**

*   注意内存对齐；
    
*   128 是个槛，常用的数据成员可考虑放在前 128 字节中，不常用的或大的数据成员可考虑放在后面；
    
*   注重性能优化的同时也需要权衡一下代码的可读性。
    

打完收工。  

- EOF -