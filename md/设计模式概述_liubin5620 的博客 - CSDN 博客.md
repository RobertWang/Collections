> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/liubin5620/article/details/104507602)

**目录**

[产生背景](#t0)

[概念](#t1)

[学习意义](#t2)

[分类方法](#t3)

[脑图展示](#t4)

[前提知识储备](#t5)

[类之间关系](#t6)

[面向对象设计原则](#t7)

[面向对象设计原则提炼](#t8)

[设计模式简述](#t9)

产生背景
====

“设计模式” 这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

 1995 年，艾瑞克 · 伽马（ErichGamma）、理査德 · 海尔姆（Richard Helm）、拉尔夫 · 约翰森（Ralph Johnson）、约翰 · 威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的 “四人组”（Gang of Four，GoF）匿名著称。

概念
==

       设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说：设计模式是前辈们对代码开发经验的总结，它是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

学习意义
====

        1、设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。  
        2、可以提高程序员的思维能力、编程能力和设计能力。  
        3、使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。  
        4、使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

分类方法
====

        一、根据模式的目的：  
            1、创建型模式：用于描述 “怎样创建对象”，它的主要特点是 “将对象的创建与使用分离”。  
                         单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。  
              
            2、结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。  
                         代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。  
              
            3、行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。  
                         模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。  
              
        二、根据模式作用范围：  
            1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。  
                      工厂方法、（类）适配器、模板方法、解释器模式。  
                        
            2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。  
                       单例、原型、抽象工厂、建造者、代理、(对象）适配器、桥接、装饰、外观、享元、组合、  
                       策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录模式。

脑图展示
====

![](https://img-blog.csdnimg.cn/202002252313572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWJpbjU2MjA=,size_16,color_FFFFFF,t_70) 设计模式脑图展示

前提知识储备
======

类之间关系
-----

![](https://img-blog.csdnimg.cn/20200301171923435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWJpbjU2MjA=,size_16,color_FFFFFF,t_70)

1、依赖关系  
       依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。  
       在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。  
       譬如：人与手机的关系，人通过手机的语音传送方法打电话。  
              
        2、关联关系  
       关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。  
       关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。需要注意的是关联可以是双向的，也可以是单向的。  
              
        3、聚合关系  
       聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。  
       聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。  
       例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。  
             
        4、组合关系  
       组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。  
       在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。  
       例如，头和嘴的关系，没有了头，嘴也就不存在了。

        5、泛化关系  
        泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。  
       在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类。  
              
        6、实现关系  
        实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。  
        例如，汽车和船实现了交通工具。

面向对象设计原则
--------

1、开闭原则：  
       1988 年勃兰特 · 梅耶在他的著作《面向对象软件构造》中提出：软件实体应当对扩展开放，对修改关闭。（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。

2、里氏替换原则：  
       1987 年里斯科夫（Liskov）女士在一篇名为《数据抽象和层次》的文章中提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。

3、依赖倒置原则：  
       1996 年罗伯特 · 马丁指出高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。

4、单一职责原则：  
       罗伯特 ·C. 马丁（Robert C. Martin）在《敏捷软件开发：原则、模式和实践》一书中提出：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。

5、接口隔离原则：  
       2002 年罗伯特 ·C. 马丁给 “接口隔离原则” 的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

 6、迪米特法则：  
       产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩 · 荷兰（Ian Holland）提出并被 UML 创始者之一的布奇（Booch）普及。迪米特法则的定义是：只与你的直接朋友交谈，不跟 “陌生人” 说话（Talk only to your immediate friends and not to strangers）。

7、合成复用原则：  
       它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

面向对象设计原则提炼
----------

1、封装变化。

2、多用组合少用继承。

3、针对接口编程，不针对实现编程。

4、为交互对象之间的松耦合设计而努力。

5、类应该对扩展开放，对修改关闭。

6、要依赖抽象，不要依赖具体类。

设计模式简述
======

1、单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。

2、原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

3、工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。

4、抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

5、建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

6、代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

7、适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

8、桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

9、装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。

10、外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

11、享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。

12、组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

13、模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

14、策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

15、命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。

16、职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

17、状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。

18、观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

19、中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

20、迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

21、访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

22、备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

23、解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。