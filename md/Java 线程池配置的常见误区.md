> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&mid=2247519624&idx=2&sn=28dbed1e18aa4c1d47358ca4673b2f4d&chksm=ce0e3a0bf979b31d7d002db8264febf5fc624542056fe526bf8007808e043598578bd0efef6b&mpshare=1&scene=1&srcid=0714LLtrZOMYPA6tekgN1FXf&sharer_sharetime=1626248972452&sharer_shareid=7fece245937ac96f04f0fb8e1311fff1#rd)

### **前言**

由于线程的创建和销毁对操作系统来说都是比较重量级的操作，所以线程的池化在各种语言内都有实践，当然在 Java 语言中线程池是也非常重要的一部分，有 Doug Lea 大神对线程池的封装，我们使用的时候是非常方便，但也可能会因为不了解其具体实现，对线程池的配置参数存在误解。

*   1、当一个任务被提交后，线程池首先检查正在运行的线程数是否达到核心线程数，如果未达到则创建一个线程。
    
*   2、如果线程池内正在运行的线程数已经达到了核心线程数，任务将会被放到 BlockingQueue 内。
    
*   3、如果 BlockingQueue 已满，线程池将会尝试将线程数扩充到最大线程池容量。
    
*   4、如果当前线程池内线程数量已经达到最大线程池容量，则会执行拒绝策略拒绝任务提交。流程如图（摘自美团技术博客）：
    

### **核心池**

有关核心池最常见的一个误区是没搞清楚核心池内线程的创建时机，这个问题，我觉得甩 10% 的锅给 Doug Lea 大神应该不算过分，因为他在文档里写道 “If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task”，其中 "running" 这个词就比较有歧义，因为在我们理解里 running 是指当前线程已被操作系统调度，拥有操作系统时间分片，或者被理解为正在执行某个任务。

基于以上的理解，我们很容易就认为如果任务的 QPS 非常低，线程池内线程数量永远也达不到 coreSize。即如果我们配置了 coreSize 为 1000，实际上 QPS 只有 1，单个任务耗时 1s，那么核心池大小就会一直是 1，即使有流量抖动，核心池也只会被扩容到 3。因为一个线程每秒执行执行一个任务，刚好不用创建新线程就足以应对 1QPS。

### **创建过程**

因为核心池的设计初衷是想它能作为常驻池，承载日常流量，所以它应该被尽快初始化，于是线程池的逻辑是在没有达到 coreSize 之前，每一个任务都会创建一个新的线程，对应的源码为：

基于此，我们对一些高并发服务进行的预热，其实并不是期望 JVM 能对热点代码做 JIT 等优化，对线程池、连接池和本地缓存的预热才是重点。

### **BlockingQueue**

### **运行模型**

最常见的错误是不理解线程池的运行模型。首先要明确的一点是线程池并没有准确的调度功能，即它无法感知有哪些线程是处于空闲状态的，并把提交的任务派发给空闲线程。线程池采用的是” 生产者 - 消费者” 模式，除了触发线程创建的任务（线程的 firstTask）不会入 BlockingQueue 外，其他任务都要进入到 BlockingQueue，等待线程池内的线程消费，而任务会被哪个线程消费到完全取决于操作系统的调度。

### **BlockingQueue 的缓冲作用**

这种情况下，BlockingQueue 的重要的意义就是它是一个能长时间存储任务的容器，能以很小的代价为线程池提供缓冲。根据上文可知，线程池能支持 BlockingQueue Size 个任务同时提交，我们把最大同时提交的任务个数，称为并发量，配置线程池时，了解并发量异常重要。

### **并发量的计算**

比如请求间隔严格相同的接口，平均 QPS 为 1000，它的并发量峰值是多少呢？我们并没有办法估算，因为如果任务执行时间为 1ms，那么它的并发量只有 1；而如果任务执行时间为 1s，那么并发量峰值为 1000。

计算并发量，我一般的经验值是 QPS * 平均响应时间，再留上一倍的冗余，但如果业务重要的话，BlockingQueue Size 设置大一些也无妨（1000 或以上），毕竟每个任务占用的内存量很有限。

### **考虑运行时**

### **GC**

我们都知道 GC 是 Stop the World 的，但这里的 World 指的是 JVM，而一个请求 I/O 的准备和完成是操作系统在进行的，JVM 停止了，但操作系统还是会正常受理请求，在 JVM 恢复后执行，所以 GC 是会堆积请求的。

### **业务峰值**

假如接口的流量大部分来自于一个定时程序，那么平均 QPS 就没有了任何意义，线程池设计时就要考虑给 BlockingQueue 的 Size 设置一个大一些的值；而如果流量非常不平均，一天内只有某一小段时间才有高流量的话，而且线程资源紧张的情况下，就要考虑给线程池的 maxSize 留下较大的冗余；在流量尖刺明显而响应时间不那么敏感时，也可以设置较大的 BlockingQueue，允许任务进行一定程度的堆积。

### **小结**

总结线程池的配置时，我最大的感受是一定要读源码！读源码！读源码！只看一些书和文章的总结是无法吃透一些重要概念的，即使搞懂了大部分也很容易会在一些角落踩坑。深入理解原理后，面对复杂情况，才有灵活配置的能力。