> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&mid=2247512685&idx=3&sn=b94173108afd923e53bcc69c975b32a9&chksm=9fac2da6a8dba4b0855921039a97d6cfc28fdac0012a8b442eef6e49b9d7215445064e78897f&mpshare=1&scene=1&srcid=0724JxXwIM82YhmWtGHTlzt8&sharer_sharetime=1627116203132&sharer_shareid=7fece245937ac96f04f0fb8e1311fff1#rd)

为什么我们需要定时任务
-----------

*   支付系统每天凌晨 1 点跑批，进行一天清算，每月 1 号进行上个月清算
    
*   电商整点抢购，商品价格 8 点整开始优惠
    
*   12306 购票系统，超过 30 分钟没有成功支付订单的，进行回收处理
    
*   商品成功发货后，需要向客户发送短信提醒
    

> 类似的业务场景非常多，我们怎么解决？

如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送 MQ 消息到队列，然后去消费 mq 消息，发送短信。

> a) 时间驱动 / 事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次
> 
> b) 批量处理 / 逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费
> 
> c) 实时性 / 非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip 升级
> 
> d) 系统内部 / 系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间

有哪些定时任务的框架
----------

#### 单机

*   timer：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask 类是一个定时任务类，该类实现了 Runnable 接口，缺点异常未检查会中止线程
    
*   ScheduledExecutorService：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间
    
*   spring 定时框架：配置简单功能较多，如果系统使用单机的话可以优先考虑 spring 定时器
    

#### 分布式

*   Quartz：Java 事实上的定时任务标准。但 Quartz 关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然 Quartz 可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能
    
*   TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用 timer 而非线程池执行任务调度。众所周知，timer 在处理异常状况时是有缺陷的。而且 TBSchedule 作业类型较为单一，只能是获取 / 处理数据一种模式。还有就是文档缺失比较严重
    
*   elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用 zookeeper 实现分布式协调，实现任务高可用以及分片，目前是版本 2.15，并且可以支持云开发。
    
*   Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的 elastic-job 版本 1 开发，并且可以很好的部署到 docker 容器上。
    
*   xxl-job: 是大众点评员工徐雪里于 2015 年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。
    

分布式任务调度系统对比
-----------

> 参与对比的可选系统方案：elastic——job （以下简称 E-Job）与 xxx-job(以下简称 X-Job)

#### 项目背景及社区力量

_X-Job_　：　大众点评公司下员工许雪里、贡献者 3 人;　github 有 2470star、1015fork　|　QQ 讨论群 6 个　|　有登记在使用的超过 40 家公司　|　文档齐全 _E-Job_　：　当当网开源，贡献者 17 人;　github 有 2524star、1015fork　|　QQ 讨论群１个、源码讨论群１个　|　有登记在使用的超过 50 家公司　|　文档齐全　｜　有明确的发展计划

#### 支持集群部署

> 执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses / 调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。

> 作业注册中心：基于 Zookeeper 和其客户端 Curator 实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。

#### 多节点部署时任务不能重复执行

_X-Job_　：　使用 Quartz 基于数据库的分布式功能

_E-Job_　 ：　将任务拆分为 n 个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job 将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。

#### 日志可追溯

_X-Job_　：　支持，有日志查询界面

_E-Job_　：　可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job 目前提供了基于关系型数据库两种事件订阅方式记录事件。

#### 监控告警

_X-Job_　：　调度失败时，将会触发失败报警，如发送报警邮件。

> 任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔

_E-Job_　：　通过事件订阅方式可自行实现

> 作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常, 如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于 0，可选择报警。）

#### 弹性扩容缩容

_X-Job_　：　使用 Quartz 基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力

_E-Job_　：　通过 zk 实现各服务的注册、控制及协调

#### 支持并行调度

_X-Job_　：　调度系统多线程（默认 10 个线程）触发调度运行，确保调度精确执行，不被堵塞。

_E-Job_　：　采用任务分片方式实现。将一个任务拆分为 n 个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。

#### 高可用策略

_X-Job_　：　“调度中心” 通过 DB 锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；

_E-Job_　：　调度器的高可用是通过运行几个指向同一个 ZooKeeper 集群的 Elastic-Job-Cloud-Scheduler 实例来实现的。ZooKeeper 用于在当前主 Elastic-Job-Cloud-Scheduler 实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于” 待命” 状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。

#### 失败处理策略

_X-Job_　：　调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；

_E-Job_　：　弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。

动态分片策略
------

_X-Job_　：　分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。

> 执行器集群部署时，任务路由策略选择” 分片广播” 情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；

_E-Job_　：　支持多种分片策略，可自定义分片策略

> 默认包含三种分片策略：基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定 IP 升降序算法的分片策略、根据作业名的哈希值对 Job 实例列表进行轮转的分片策略，支持自定义分片策略
> 
> elastic-job 的分片是通过 zookeeper 来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的 Job 实例加入集群 b、现有的 Job 实例下线（如果下线的是 leader 节点，那么先选举然后触发分片算法的执行） c、主节点选举”

#### 和 quartz 框架对比

*   调用 API 的的方式操作任务，不人性化；
    
*   需要持久化业务 QuartzJobBean 到底层数据表中，系统侵入性相当严重。
    
*   调度逻辑和 QuartzJobBean 耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；
    
*   Quartz 关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然 Quartz 可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。
    

综合对比
----

![](https://mmbiz.qpic.cn/mmbiz_png/DMP9YVibia1dQaUVC9k2jNEx5Rs5I0dahUcUfSZ7qW5QPKga3gAMicPs0GNrps8sPd5FBkGrMBkMVp3hTHPVUKa8w/640?wx_fmt=png)

总结和结论
-----

**共同点：**

E-Job 和 X-job 都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。

**不同点：**

X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在 “用户基数相对少，服务器数量在一定范围内” 的情景下使用。

E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在 “数据量庞大，且部署服务器数量较多” 时使用。

附定时任务的其他方案
----------

发货后超过 10 天未收货时系统自动确认收货的多种实现方式：

> 每天定时半夜筛选第二天 可以自动确认收货的订单, 然后第二天 每 10 分钟 执行一次确认收货 开销不会太大吧 时间也相对精确
> 
> 自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。
> 
> 延迟和定时消息投递
> 
> ActiveMQ 提供了一种 broker 端消息定时调度机制。适用于：1、不希望消息马上被 broker 投递出去，而是想要消息 60 秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数
> 
> RabbitMQ 可以针对 Queue 和 Message 设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为 dead letter。利用 DLX，当消息在一个队列中变成死信后，它能被重新 publish 到另一个 Exchange。这时候消息就可以重新被消费。