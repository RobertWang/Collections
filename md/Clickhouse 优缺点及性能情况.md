> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/capacity-yang/p/13094536.html)

优点：

1，为了高效的使用 CPU，数据不仅仅按列存储，同时还按向量进行处理；

2，数据压缩空间大，减少 IO；处理单查询高吞吐量每台服务器每秒最多数十亿行；

3，索引非 B 树结构，不需要满足最左原则；只要过滤条件在索引列中包含即可；即使在使用的数据不在索引中，由于各种并行处理机制 ClickHouse 全表扫描的速度也很快；

4，写入速度非常快，50-200M/s，对于大量的数据更新非常适用。

缺点：

1，不支持事务，不支持真正的删除 / 更新；

2，不支持高并发，官方建议 qps 为 100，可以通过修改配置文件增加连接数，但是在服务器足够好的情况下；

3，SQL 满足日常使用 80% 以上的语法，join 写法比较特殊；最新版已支持类似 SQL 的 join，但性能不好；

4，尽量做 1000 条以上批量的写入，避免逐行 insert 或小批量的 insert，update，delete 操作，因为 ClickHouse 底层会不断的做异步的数据合并，会影响查询性能，这个在做实时数据写入的时候要尽量避开；

5，Clickhouse 快是因为采用了并行处理机制，即使一个查询，也会用服务器一半的 CPU 去执行，所以 ClickHouse 不能支持高并发的使用场景，默认单查询使用 CPU 核数为服务器核数的一半，安装时会自动识别服务器核数，可以通过配置文件修改该参数。

全量数据导入：数据导入临时表 -> 导入完成后，将原表改名为 tmp1 -> 将临时表改名为正式表 -> 删除原表

增量数据导入： 增量数据导入临时表 -> 将原数据除增量外的也导入临时表 -> 导入完成后，将原表改名为 tmp1-> 将临时表改成正式表 -> 删除原数据表

相关优化：

1，关闭虚拟内存，物理内存和虚拟内存的数据交换，会导致查询变慢。

2，为每一个账户添加 join_use_nulls 配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准 SQL 中的 Null 值。

3，JOIN 操作时一定要把数据量小的表放在右边，ClickHouse 中无论是 Left Join 、Right Join 还是 Inner Join 永远都是拿着右表中的每一条记录到左表中查找该记录是否存在，所以右表必须是小表。

4，批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致 ClickHouse 无法及时对新导入的数据进行合并，从而影响查询性能。

5，尽量减少 JOIN 时的左右表的数据量，必要时可以提前对某张表进行聚合操作，减少数据条数。有些时候，先 GROUP BY 再 JOIN 比先 JOIN 再 GROUP BY 查询时间更短。

6，ClickHouse 的分布式表性能性价比不如物理表高，建表分区字段值不宜过多，防止数据导入过程磁盘可能会被打满。

7，CPU 一般在 50% 左右会出现查询波动，达到 70% 会出现大范围的查询超时，CPU 是最关键的指标，要非常关注。

性能情况

1, 单个查询吞吐量：如果数据被放置在 page cache 中，则一个不太复杂的查询在单个服务器上大约能够以 2-10GB／s（未压缩）的速度进行处理（对于简单的查询，速度可以达到 30GB／s）。如果数据没有在 page cache 中的话，那么速度将取决于你的磁盘系统和数据的压缩率。例如，如果一个磁盘允许以 400MB／s 的速度读取数据，并且数据压缩率是 3，则数据的处理速度为 1.2GB/s。这意味着，如果你是在提取一个 10 字节的列，那么它的处理速度大约是 1-2 亿行每秒。对于分布式处理，处理速度几乎是线性扩展的，但这受限于聚合或排序的结果不是那么大的情况下。

2，处理短查询的延时时间：数据被 page cache 缓存的情况下，它的延迟应该小于 50 毫秒 (最佳情况下应该小于 10 毫秒)。 否则，延迟取决于数据的查找次数。延迟可以通过以下公式计算得知： 查找时间（10 ms） * 查询的列的数量 * 查询的数据块的数量。

3，处理大量短查询：ClickHouse 可以在单个服务器上每秒处理数百个查询（在最佳的情况下最多可以处理数千个）。但是由于这不适用于分析型场景。建议每秒最多查询 100 次。

4，数据写入性能：建议每次写入不少于 1000 行的批量写入，或每秒不超过一个写入请求。当使用 tab-separated 格式将一份数据写入到 MergeTree 表中时，写入速度大约为 50 到 200MB/s。如果您写入的数据每行为 1Kb，那么写入的速度为 50，000 到 200，000 行每秒。如果您的行更小，那么写入速度将更高。为了提高写入性能，您可以使用多个 INSERT 进行并行写入，这将带来线性的性能提升。

count: 千万级别，500 毫秒，1 亿 800 毫秒  2 亿 900 毫秒 3 亿 1.1 秒  
group: 百万级别 200 毫米，千万 1 秒，1 亿 10 秒，2 亿 20 秒，3 亿 30 秒  
join：千万 - 10 万 600 毫秒， 千万 - 百万：10 秒，千万 - 千万 150 秒

ClickHouse 并非无所不能，查询语句需要不断的调优，可能与查询条件有关，不同的查询条件表是左 join 还是右 join 也是很有讲究的。

其他补充：

1，MySQL 单条 SQL 是单线程的，只能跑满一个 core，ClickHouse 相反，有多少 CPU，吃多少资源，所以飞快；  
2，ClickHouse 不支持事务，不存在隔离级别。ClickHouse 的定位是分析性数据库，而不是严格的关系型数据库。  
3，IO 方面，MySQL 是行存储，ClickHouse 是列存储，后者在 count() 这类操作天然有优势，同时，在 IO 方面，MySQL 需要大量随机 IO，ClickHouse 基本是顺序 IO。  
有人可能觉得上面的数据导入的时候，数据肯定缓存在内存里了，这个的确，但是 ClickHouse 基本上是顺序 IO。对 IO 基本没有太高要求，当然，磁盘越快，上层处理越快，但是 99% 的情况是，CPU 先跑满了（数据库里太少见了，大多数都是 IO 不够用）。