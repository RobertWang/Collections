> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/xw8hcN0IUW_iXePPeuAKiw)

> 在嵌入式开发中经常会看到消息队列的身影，队列的应用是很广泛的，它可以应用的场景有很多。

在嵌入式开发中经常会看到消息队列的身影，队列的应用是很广泛的，它可以应用的场景有很多，比如缓存通信消息，暂存执行内容，数据顺序转发等的操作。
----------------------------------------------------------------------

那到底什么是队列呢？

队列属于一种线性表的数据结构，跟栈有些类似，但是又不相同。队列的不同之处在于它只允许在一端（front）进行删除操作，而在另外一端（rear）进行插入操作，是一种有约束的线性表结构。在队列中进行插入一端称为队列尾，进行删除操作的一端称为队列头。

总而言之：

```
队头：指的是允许元素被删除的一端；
队尾：指的是允许元素被插入的一端；
入队：队列的插入操作。
出队：队列的删除操作。
空队：队列中没有任何元素时称为空队列。

```

队列的示意图参见下面：
-----------

![](https://mmbiz.qpic.cn/mmbiz_png/4NMbjrAPkKV6y0GTgzLzUGqTfMYppNwcdHSMrNZibgVG7yRJfUJicNI1ySN94hfZfT4ic5JoVYsMXBRZ78CRwNWGQ/640?wx_fmt=png)

在开发中，特别是涉及到消息数据的接收或者发送的时候，消息多的时候可能 MCU 一时半会处理不来，就需要考虑先将消息先接收并缓存起来，然后由 MCU 按照消息的先后顺序一一去处理，这种情况下队列就是比较好的选择。
---------------------------------------------------------------------------------------------------------

队列的实现可以自己写一个，也可以参考网上别人实现的开源代码，原理都是差不多的，只是要注意一点：消息的结构的要按照自己的实际使用需求进行定义。

本文分享一个 guthub 上的消息队列的实现：

仓库链接如下：

```
https://github.com/xiaoxinpro/QueueForMcu

```

这个队列是基于单片机实现的队列功能模块，可以用于 8 位、16 位、32 位的单片机，特别适合应用在非 RTOS 的单片机应用中，可以兼容大多数的单片机平台，对资源比较稀缺的单片机也是可以应用的。
--------------------------------------------------------------------------------------------------

这个队列功能模块的使用方式如下：

1、定义队列的消息结构
===========

队列的消息结构定义如下：

```
typedef struct QUEUE_HandleTypeDef{
unsigned int head;                      //队列头指针
unsigned int tail;                      //队列尾指针
unsigned int buffer_length;             //队列缓存长度（初始化时赋值）
    QUEUE_DATA_T * buffer;                  //队列缓存数组（初始化时赋值）
}QUEUE_HandleTypeDef;

```

在上面的消息结构中，QUEUE_DATA_T 需要自定义为自己项目中需要用到的数据类型。

在 queue.h 文件中可以找到 QUEUE_DATA_T 的定义如下：

```
#define QUEUE_DATA_T  unsigned char         //队列数据类型定义

```

修改这个数据类型的定义即可。

**2、创建队列的缓存**
=============

在创建队列前要手动创建一个队列缓存区，用于存放队列数据。如下创建一个大小为 512 的队列缓存区。

```
QUEUE_DATA_T BufferUartTx[512];

```

**3、初始化队列**
===========

队列的缓存区定义好以后，就需要调用初始化函数来进行队列的创建，初始化函数如下：

```
void Queue_Init(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * buffer, unsigned int len)

```

参数说明：

<table><tbody><tr><td width="80" colspan="1" rowspan="1" height="48" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>参数名<o:p></o:p></section></td><td width="441" colspan="1" rowspan="1" height="48" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>描述<o:p></o:p></section></td></tr><tr><td width="100" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>hqueue<o:p></o:p></section></td><td width="441" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要初始化的队列结构，如果二次初始化将清空原队列的内容。<o:p></o:p></section></td></tr><tr><td width="100" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>buffer<o:p></o:p></section></td><td width="441" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>队列缓存的首地址指针<o:p></o:p></section></td></tr><tr><td width="100" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>len<o:p></o:p></section></td><td width="441" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>队列长度，不能比队列缓存长度还要大。<o:p></o:p></section></td></tr></tbody></table>

返回值说明：

该函数会返回一个 QUEUE_StatusTypeDef 枚举数据类型，返回值会根据队列状态返回以下几个值：

<table class=""><tbody><tr><td width="199" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>返回值<o:p></o:p></section></td><td width="338" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>描述<o:p></o:p></section></td></tr><tr><td width="224" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>QUEUE_OK<o:p></o:p></section></td><td width="338" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>数据压入队列成功。<o:p></o:p></section></td></tr><tr><td width="224" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>QUEUE_OVERLOAD<o:p></o:p></section></td><td width="338" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>未压入数据到队列中，原因队列已满。<o:p></o:p></section></td></tr></tbody></table>

**4、数据压入队列**
============

（1）单个消息压入队列

将数据压入队列尾部使用 Queue_Push 函数，该函数原型如下：

```
QUEUE_StatusTypeDef Queue_Push(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T data)

```

参数说明：

<table><tbody><tr><td width="93" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>参数名<o:p></o:p></section></td><td width="313" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">描述<o:p></o:p></section></td></tr><tr><td width="113" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>hqueue<o:p></o:p></section></td><td width="313" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要压入数据的队列结构。<o:p></o:p></section></td></tr><tr><td width="113" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>data<o:p></o:p></section></td><td width="313" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>待压入队列的数据。<o:p></o:p></section></td></tr></tbody></table>

返回值说明：

该函数会返回一个 QUEUE_StatusTypeDef 枚举数据类型，返回值会根据队列状态返回以下几个值：

<table><tbody><tr><td width="196" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>返回值<o:p></o:p></section></td><td width="326" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>描述<o:p></o:p></section></td></tr><tr><td width="216" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>QUEUE_OK<o:p></o:p></section></td><td width="346" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>数据压入队列成功。<o:p></o:p></section></td></tr><tr><td width="216" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>QUEUE_OVERLOAD<o:p></o:p></section></td><td width="346" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>未压入数据到队列中，原因队列已满。<o:p></o:p></section></td></tr></tbody></table>

（2）多个消息压入队列

若需要将多个数据（数组）压入队列可以使用 Queue_Push_Array 函数，原理上循环调用 Queue_Push 函数来实现的，函数原型如下：

```
unsigned int Queue_Push_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len)

```

参数说明：

<table><tbody><tr><td width="115" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>参数名<o:p></o:p></section></td><td width="255" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>描述<o:p></o:p></section></td></tr><tr><td width="135" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>hqueue<o:p></o:p></section></td><td width="255" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要压入数据的队列结构。<o:p></o:p></section></td></tr><tr><td width="135" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>pdatas<o:p></o:p></section></td><td width="255" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>待压入队列的数组首地址。<o:p></o:p></section></td></tr><tr><td width="135" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>len<o:p></o:p></section></td><td width="255" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>待压入队列的数组长度。<o:p></o:p></section></td></tr></tbody></table>

当数组长度大于队列剩余长度时，数组多余的数据将被忽略。

返回值说明：

```
该函数将返回实际被压入到队列中的数据长度。
当队列中的剩余长度富余时，返回值将等于参数 len 的值。
当队列中的剩余长度不足时，返回值为实际被压入到队列的数据长度。

```

**5、消息出队**
==========

（1）单数据弹出

将队列头部数据弹出队列使用 Queue_Pop 函数，需要注意的是，弹出的数据将从队列中删除，该函数原型如下：

```
QUEUE_StatusTypeDef Queue_Pop(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdata)

```

参数说明：

<table><tbody><tr><td width="116" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">参数名<o:p></o:p></section></td><td width="309" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>描述<o:p></o:p></section></td></tr><tr><td width="136" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">hqueue<o:p></o:p></section></td><td width="309" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要弹出数据的队列结构。<o:p></o:p></section></td></tr><tr><td width="136" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">pdata<o:p></o:p></section></td><td width="309" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>用于保存弹出数据变量的指针。<o:p></o:p></section></td></tr></tbody></table>

返回值说明：

该函数会返回一个 QUEUE_StatusTypeDef 枚举数据类型，返回值会根据队列状态返回以下几个值：

<table><tbody><tr><td width="138" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section class="">返回值<o:p></o:p></section></td><td width="339" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>描述<o:p></o:p></section></td></tr><tr><td width="158" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">QUEUE_OK<o:p></o:p></section></td><td width="359" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>数据弹出队列成功。<o:p></o:p></section></td></tr><tr><td width="158" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">QUEUE_VOID<o:p></o:p></section></td><td width="359" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>未弹出数据到队列中，原因队列为空。<o:p></o:p></section></td></tr></tbody></table>

（2）多数据弹出

若需要将多个数据弹出队列可以使用 Queue_Pop_Array 函数，原理上循环调用 Queue_Pop 函数来实现的，需要注意的是，成功弹出的数据将从队列中删除，函数原型如下：

```
unsigned int Queue_Pop_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len)

```

参数说明：

<table><tbody><tr><td width="162" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>参数名<o:p></o:p></section></td><td width="336" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>描述<o:p></o:p></section></td></tr><tr><td width="182" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>hqueue<o:p></o:p></section></td><td width="356" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要弹出数据的队列结构。<o:p></o:p></section></td></tr><tr><td width="182" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>pdatas<o:p></o:p></section></td><td width="356" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>用于保存弹出数据数组的首地址。<o:p></o:p></section></td></tr><tr><td width="182" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>len<o:p></o:p></section></td><td width="356" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要弹出数据数组的长度。<o:p></o:p></section></td></tr></tbody></table>

当需要弹出数据的长度大于队列中的数据长度时，弹出数组多余的空间将不会被赋值。

返回值说明：

```
该函数将返回实际从队列中弹出的数据长度。
当队列中的数据长度足够时，返回值将等于参数 len 的值。
当队列中的数据长度不足时，返回值为实际从队列中弹出的数据长度。

```

**6、清空队列**
==========

当需要清空队列数据时，无需弹出所有数据，只需要调用 Queue_Clear 即可快速清空指定队列，在创建队列时会调用此函数来初始化队列，因此对于刚创建完成的队列无需调用清空队列函数。

函数原型：

```
void Queue_Clear(QUEUE_HandleTypeDef * hqueue)

```

参数说明：

<table><tbody><tr><td width="109" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section class="">参数名<o:p></o:p></section></td><td width="365" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section>描述<o:p></o:p></section></td></tr><tr><td width="129" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">hqueue<o:p></o:p></section></td><td width="365" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>需要清空的队列结构。<o:p></o:p></section></td></tr></tbody></table>

**7、获取队列的数据量长度**
================

当需要获取队列中的数据长度时，调用 Queue_Count 函数，函数原型如下：

```
unsigned int Queue_Count(QUEUE_HandleTypeDef * hqueue)

```

参数说明：

<table><tbody><tr><td width="101" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);"><section>参数名<o:p></o:p></section></td><td width="327" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">描述<o:p></o:p></section></td></tr><tr><td width="101" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">hqueue<o:p></o:p></section></td><td width="327" colspan="1" rowspan="1" data-style="background: rgb(255, 255, 255); vertical-align: middle; padding: 6px 13px; border-color: rgb(203, 205, 209);" class=""><section class="">需要获取数据长度的队列结构。<o:p></o:p></section></td></tr></tbody></table>

返回值说明：

```
该函数将返回队列中的数据长度。
返回值范围在0到创建队列时的长度之间。

```

特此感谢各路大佬分享的开源代码，让我们广大开发者有机会学习和使用到更多使用的项目开发技巧，更加方便我们的开发工作。