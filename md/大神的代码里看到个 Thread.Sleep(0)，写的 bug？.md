> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/sT2t210yS79pgGZNZeNvJg)

前 言
---

、假设现在是 2022-01-01 00:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2022-01-01 00:00:01.000 的时候，这个线程会不会被唤醒？

回顾操作系统原理
--------

操作系统中，CPU 竞争有很多种策略。Unix 系统使用的是时间片算法，而 Windows 则属于抢占式的。

在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。

如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。

所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢占式操作系统中，操作系统假设所有的进程都是 “人品很好” 的，会主动退出 CPU 。

在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。

当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。

我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个 CPU），10 个等待吃蛋糕的人（10 个进程）。

这样看来，这个场面就有意思了——可能有些人是漂亮 MM，因此具有高优先级，于是她就可以经常来吃蛋糕。

可能另外一个人是个丑男，而且很 ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。

那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。

上面的场景里面，5 号 MM 在吃了一次蛋糕之后，觉得已经有 8 分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。

这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略 5 号 mm。Sleep 函数就是干这事的，他告诉操作系统 “在未来的多少毫秒内我不参与 CPU 竞争”

看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。

第一个问题
-----

对于第一个问题，答案是：不一定。

因为你只是告诉操作系统：在未来的 1000 毫秒内我不想再参与到 CPU 竞争。那么 1000 毫秒过去之后，这时候也许另外一个线程正在使用 CPU，那么这时候操作系统是不会重新分配 CPU 的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行 CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU 还是可能被其他线程抢占去。

与此相似的，Thread 有个 Resume 函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是 “告诉操作系统我从现在起开始参与 CPU 竞争了”，这个函数的调用并不能马上使得这个线程获得 CPU 控制权。

第二个问题
-----

对于第二个问题，答案是：有，而且区别很明显。

假设我们刚才的分蛋糕场景里面，有另外一个 PPMM 7 号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7 号也非常喜欢吃蛋糕，而且饭量也很大。

不过，7 号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。

不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是 7 号 mm 就换了个说法：“在未来的 0 毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连 7 号一起计算的，因为 “0 毫秒已经过去了” 嘛。

因此如果没有比 7 号更需要吃蛋糕的人出现，那么下一次 7 号还是会被叫上来吃蛋糕。

因此，Thread.Sleep(0) 的作用，就是 “触发操作系统立刻重新进行一次 CPU 竞争”。

竞争的结果也许是当前线程仍然获得 CPU 控制权，也许会换成别的线程获得 CPU 控制权。这也是我们在大循环里面经常会写一句 Thread.Sleep(0) ，因为这样就给了其他线程比如 Paint 线程获得 CPU 控制权的权力，这样界面就不会假死在那里。

另外，虽然上面提到说 “除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占 CPU 的情况，如果发现某个线程长时间霸占 CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放” 的情况。

至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着 CPU。实际上在这段时间操作系统已经进行过多次 CPU 竞争了，只不过其他线程在获得 CPU 控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起...... 因此反应到界面上，看起来就好像这个线程一直在霸占着 CPU 一样。