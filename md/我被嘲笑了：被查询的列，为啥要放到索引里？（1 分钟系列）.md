> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651971103&idx=1&sn=1228bc31783bc9121827e153dfa12fcf&chksm=bd2d6bc38a5ae2d5c74151a34f063d85092c9ce8108ea5e4366949912ef4012e8b3b31712176&mpshare=1&scene=1&srcid=0826bJLHK8BQAXcPa2Rsqw7u&sharer_sharetime=1661520207715&sharer_shareid=8a467675e94cd5b11b6640b7770d6cc6#rd)

_select id,name where name='shenjian'_

_select id,name__,sex_ _where name='shenjian'_

**多查询了一个属性，为何检索过程完全不同？**

**什么是回表查询？**

**什么是索引覆盖？**

**如何实现索引覆盖？**

**哪些场景，可以利用索引覆盖来优化 SQL？**

这些，这是今天要分享的内容。

_画外音：本文试验基于 MySQL5.6-InnoDB。_

**一、什么是回表查询？**

这先要从 InnoDB 的索引实现说起，InnoDB 有两大类索引：

（1）聚集索引 (clustered index)；

（2）普通索引 (secondary index)；

**InnoDB 聚集索引和普通索引有什么差异？  
**

InnoDB **聚集索引**的叶子节点存储行记录，因此， InnoDB 必须要有，且只有一个聚集索引：

（1）如果表定义了 PK，则 PK 就是聚集索引；

（2）如果表没有定义 PK，则第一个 not NULL unique 列是聚集索引；

（3）否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引；

_画外音：所以 PK 查询非常快，直接定位行记录。_

InnoDB **普通索引**的叶子节点存储主键值。

_画外音：注意，不是存储行记录头指针，MyISAM 的索引叶子节点存储记录指针。_

举个栗子，不妨设有表：

_t(id PK, name KEY, sex, flag);_

_画外音：id 是聚集索引，name 是普通索引。_

表中有四条记录：

_1, shenjian, m, A_

_3, zhangsan, m, A_

_5, lisi, m, A_

_9, wangwu, f, B_

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65fmXwWV74giaiaVZBY9THnUP62l9XVyFGmn5LUg0jlGsxQjTR2ZtlxLUA/640?wx_fmt=png)

两个 B + 树索引分别如上图：

（1）id 为 PK，聚集索引，叶子节点存储行记录；

（2）name 为 KEY，普通索引，叶子节点存储 PK 值，即 id；

既然从普通索引无法直接定位行记录，那**普通索引的查询过程是怎么样的呢？**

通常情况下，需要扫码两遍索引树。

例如：

_select * from t where name='lisi';_

**是如何执行的呢？**

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65ibf3L5PzLaut1zvV9G4rPr48iaOgONxm2bc1FI6AF8388xyfFTvtVbFQ/640?wx_fmt=png)

如**粉红色**路径，需要扫码两遍索引树：

（1）先通过普通索引定位到主键值 id=5；

（2）在通过聚集索引定位到行记录；

这就是所谓的**回表查询**，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

**二、什么是索引覆盖** **(Covering index)****？**

额，楼主并没有在 MySQL 的官网找到这个概念。

借用一下 SQL-Server 官网的说法。

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65C3V0ibOS4dgPzwJas0cic0pPx4rd8Yia0kXs4tyFR0EFqZ7wOSZWwh9og/640?wx_fmt=png)

MySQL 官网，类似的说法出现在 explain 查询计划优化章节，即 explain 的输出结果 Extra 字段为 Using index 时，能够触发索引覆盖。  

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65SflW8bYddCuYm8Khse589drcPzv12DpFuExXEt74icfCFicRCSTUicYgQ/640?wx_fmt=png)

不管是 SQL-Server 官网，还是 MySQL 官网，都表达了：只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。

**三、如何实现索引覆盖？**

常见的方法是：将被查询的字段，建立到联合索引里去。

仍是《[MySQL 性能调优，这个工具最有用](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651971067&idx=1&sn=2aecdd4e79b48eef04906bbd0b669bd6&chksm=bd2d68278a5ae131a8ad53ac770c2d6214c85faa5d0e144e6b44d45531625932197ebf038f22&scene=21#wechat_redirect)》中的例子：

_create table user (_

_id int primary key,_

_name varchar(20),_

_sex varchar(5),_

_index(name)_

_)engine=innodb;_

第一个 SQL 语句：

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65ZJib9mkHOSJf9l0GGZrIsSWrBzpO6YxSyictVRb7Zp0BRZvoF98jdgiaA/640?wx_fmt=png)

_select id,name from user where name='shenjian';_

能够命中 name 索引，索引叶子节点存储了主键 id，通过 name 的索引树即可获取 id 和 name，无需回表，符合索引覆盖，效率较高。  

_画外音，Extra：__Using index__。_

第二个 SQL 语句：                     

_![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65WEPlsUZmicxkpO09eMACwcIxLqHphsZJYBYibcE0qIwVya97pyyEw5Mw/640?wx_fmt=png)_

_select id,name__,sex_ _from user where name='shenjian';_

能够命中 name 索引，索引叶子节点存储了主键 id，但 sex 字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过 id 值扫码聚集索引获取 sex 字段，效率会降低。  

_画外音，Extra：__Using index condition__。_

如果把 (name) 单列索引升级为联合索引 (name, sex) 就不同了。

_create table user (_

_id int primary key,_

_name varchar(20),_

_sex varchar(5),_

_index(name, sex)_

_)engine=innodb;_

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65vZFPB2wYyia8zEOfpayx0n7iaTAOMgN6CcPJzO32WQ5cwn2jBAkayv2Q/640?wx_fmt=png)

可以看到：

_select id,name ... where name='shenjian';_

_select id,name,__sex_ _... where name='shenjian';_

都能够命中索引覆盖，无需回表。  

_画外音，Extra：__Using index__。_

**四、哪些场景可以利用索引覆盖来优化 SQL？**

**场景 1：全表 count 查询优化**

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65oBp7Bs5CmfibaDLwVo81ucSMaGNVodCQ78PniatZvg08riamgaYNepibLQ/640?wx_fmt=png)

原表为：  

_user(PK id, name, sex)；_

直接：

_select count(name) from user;_

不能利用索引覆盖。

添加索引：

_alter table user add key(name);_

就能够利用索引覆盖提效。

**场景 2：列查询回表优化**

_select id,name,sex ... where name='shenjian';_

这个例子不再赘述，将单列索引 (name) 升级为联合索引 (name, sex)，即可避免回表。

**场景 3：分页查询**

_select id,name,sex ..._ _order by_ _name limit 500,100;_

将单列索引 (name) 升级为联合索引 (name, sex)，也可以避免回表。

**InnoDB 聚集索引普通索引**，**回表**，**索引覆盖**，希望这 1 分钟大家有收获。

提示，如果你不清楚 explain 结果 Extra 字段为 Using index 的含义，请阅读前序文章：《[MySQL 性能调优，这个工具最有用](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651971067&idx=1&sn=2aecdd4e79b48eef04906bbd0b669bd6&chksm=bd2d68278a5ae131a8ad53ac770c2d6214c85faa5d0e144e6b44d45531625932197ebf038f22&scene=21#wechat_redirect)》

****架构师之路** - 分享可落地技术**

**相关推荐**：

《[MySQL 性能调优，这个工具最有用（上）](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651971025&idx=1&sn=e60f8a2cc08e805f653140c2a1bc667d&chksm=bd2d680d8a5ae11b6b9973521c6c1de40614999650536eeef3316ee3a4a98dfd0fbbf809bf26&scene=21#wechat_redirect)》

《[MySQL 性能调优，这个工具最有用（中）](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651971067&idx=1&sn=2aecdd4e79b48eef04906bbd0b669bd6&chksm=bd2d68278a5ae131a8ad53ac770c2d6214c85faa5d0e144e6b44d45531625932197ebf038f22&scene=21#wechat_redirect)》