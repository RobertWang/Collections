> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [me.guanghechen.com](https://me.guanghechen.com/post/game/sudoku/)

> 当你想来一把数独

前言

[¶](#heading-%E5%89%8D%E8%A8%80)
--------------------------------------

前一阵子想要整理一下[精确覆盖问题和 DLX 算法](/post/algorithm/dlx/)，为了验证对算法理解的准确性写了一道数独的题目。想起大学时用 `C++` 写过一个回溯版的，当时还兴致冲冲地拿它去求解手机上的数独游戏。想到这里时还特意在电脑上翻了好久也没能找到当时的代码；想起那时在 codevs.cn 上做过提交，本来还想去嫌弃下自己当年写的代码的，结果发现 codevs.cn 好像死掉了。

时间过得可真快，转眼间又是几个春秋。而我仿佛总是在迟到，好几件事情都没能在最希望完成的时候做到，却又在过后耿耿于怀，不甘心地追逐着过去的时空里所发生的期待。不是在原地踏步，可还是开始动摇，想必继续往前的地方是没有尽头的。

什么是数独

[¶](#heading-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%8B%AC)
--------------------------------------------------------------------

一个经典的数独游戏由 x2$x^2$ ×x2$\times x^2$ 的网格构成，游戏的规则就是在网格上填数直到满足下述四个约束：

1.  网格中所有的格子都恰好填上一个数字
2.  每一行中需要出现 [1,x2]$[1, x^2]$ 之间的所有整数
3.  每一列中需要出现 [1,x2]$[1, x^2]$ 之间的所有整数
4.  每一个子方阵中需要出现 [1,x2]$[1, x^2]$ 之间的所有整数

如下所示是一个经典的 9×9$9 \times 9$ 的数独面板，其中粗线围成了 x2=9$x^2=9$ 个子方阵 [[1]](#footnote-1 "1")。

782396154461275938953814762846953271527461893139728546395142687278639415614587329

生成一个数独谜题

[¶](#heading-%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E7%8B%AC%E8%B0%9C%E9%A2%98)
--------------------------------------------------------------------------------------------------

要写一个离线游戏首先要解决数据的问题，对于数独要考虑的问题有：

*   如何确保存在解
*   如何确保唯一解
*   如何区分难度
*   如何获得更好的随机性

### 

如何确保存在解

[¶](#heading-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E8%A7%A3)

*   先生成一个填满的数独面板 G(r,c)$G(r, c)$
    
    在数独面板上选取若干个位置，无冲突地填入值，然后跑求解数独的算法，若无解，则从之前选取填入的位置中选取一个，将其上面的值擦除，再运行求解数独的算法，不断重复此过程，必然能得到一个填满的数独 [[2]](#footnote-2 "2")。
    
    如何求解数独可参见 [精确覆盖问题和 DLX 算法](/post/algorithm/dlx/)
    
*   在一个填满的数独面板中选取若干个位置，依次枚举这些位置 (r,c)$(r, c)$，尝试将上面的值 v=G(r,c)$v=G(r, c)$ 擦除，则得到一个必定存在解的数独谜题。
    

### 

如何确保唯一解

[¶](#heading-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%94%AF%E4%B8%80%E8%A7%A3)

*   在上一步选取待擦除位置的操作中增加一个校验的逻辑：尝试擦除位置 (r,c)$(r, c)$ 上的值 v=G(r,c)$v = G(r, c)$ 时，枚举 [1,x2]$[1, x^2]$ 之间除 v$v$ 外的所有整数 v′$v'$，并将格子 (r,c)$(r, c)$ 的值设置为 v′$v'$，对于每次枚举都分别跑一次求解数独的算法，若存在解，说明此位置上的值不能擦除 [[3]](#footnote-3 "3")；否则，擦除此格子上的值。

### 

如何区分难度

[¶](#heading-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E9%9A%BE%E5%BA%A6)

*   一个直观的印象是：数独面板中缺失的格子越多，想要解决的困难度越大。所以难度可以映射为在生成数独谜题时尽可能多地尝试擦除格子。

下面是一个示例，拖动滑块以切换难度。

205829747836924827496985217753291684817533956825873469

### 

如何获得更好的随机性

[¶](#heading-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%80%A7)

*   在初始填充的数独面板时：
    
    *   随机选取填充的位置
        
        将所有的格子排成一排，为方便叙述不妨将其记为 T$T$，应用 [Knuth Shuffle](/post/algorithm/shuffle/) 算法将其顺序打乱。则在随机选取格子时直接遍历打乱顺序后的 T$T$ 就可以了。一方面 [Knuth Shuffle](/post/algorithm/shuffle/) 保证了每个格子以相同的概率排在任一位置上；另一方面直接遍历 T$T$ 相比随机枚举格子，不存在重复枚举的可能性。
        
    *   按随机顺序枚举某个位置上可填入的值
        
        枚举 v′$v'$ 时可以先求出一个候选项列表 [[4]](#footnote-4 "4")，同样地，将候选项列表打乱顺序后进行遍历。
        
*   在尝试擦除格子时：
    
    *   随机选取待擦除的位置
        
        类似地，在尝试擦除格子时，可以通过遍历 T$T$ 达到随机枚举格子的效果。检查擦除此位置时是否存在多解时，直接按顺序遍历即可。
        
        为了体现难度，可以只对前 ⌈difficulty×∣∣T∣∣⌉$\displaystyle \left\lceil difficulty \times \big\lvert T \big\rvert \right\rceil$ 个格子进行擦除尝试。
        

交互设计

[¶](#heading-%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1)
----------------------------------------------------------

除了数据外还需要考虑几个交互问题：

*   [x] 切换难度和数独面板的大小
*   [x] 暂停（暂停时用模糊滤镜遮住谜题）、继续游戏、重新开始游戏
*   [x] 计时器：支持暂停、恢复、重置
*   [x] 区分谜题预填充的格子和玩家填充的格子
*   [x] 格子的输入
*   [x] 输入冲突的值时高亮提醒
*   [x] 选中非空格子时高亮与之值相同的格子
*   [x] 完成游戏时的简易提示
*   [x] 简易的提示和小抄
*   [ ] 完成某行、列或子方阵时的提示动画

附录

[¶](#heading-%E9%99%84%E5%BD%95)
--------------------------------------

下面我实现的一个简易数独，求解数独以及生成数独所需的数据的算法我封装到了 [@algorithm.ts/sudoku](https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku) 中，有兴趣的朋友可以自取。ui 组件打算之后做好整理再开源。

Size:9x9Radix:Decimal (x10)Difficulty:20RestartHINTCheat  00:00:00Score: 0Start98174354368961974913281328748273698549316291275324159×298174635547362891631958274769541328153289746482736519875493162916827453324615987

Related

[¶](#heading-related)
--------------------------------

*   [精确覆盖问题和 DLX 算法 | 光和尘](/post/algorithm/dlx/)
*   [洗牌问题和 Knuth-Shuffle 算法 | 光和尘](/post/algorithm/shuffle/)
*   [Sudoku Game | 光和尘](/game/sudoku)
*   [@algorithm.ts/sudoku](https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku)

[footnote-definitions](#footnote-definitions)

*   [↑](#reference-footnote-1)  [1]:   
    
    即上述约束中第四个约束提到的 “子方阵”
    
*   [↑](#reference-footnote-2)  [2]:   
    
    因为空的面板必然存在解，最坏的情况是擦除所有的格子上的值（当然，不可能等到所有格子都被擦除才找到解）
    
*   [↑](#reference-footnote-3)  [3]:   
    
    否则将存在多个解，因为此时格子 (r,c)$(r, c)$ 至少可以有 v$v$ 和 v′$v'$ 两种选择
    
*   [↑](#reference-footnote-4)  [4]:   
    
    因为可以简单检查格子所处的行、列、子方阵上的值构成的集合，即可在 O(x2)$O(x^2)$ 的复杂度内排除部分答案，这个预处理的开销远远小于运行求解数独算法的开销，且事先排除掉不可能的情况有利于消除边缘数据