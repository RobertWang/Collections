> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?src=11×tamp=1635784437&ver=3410&signature=wygcB4pXVNKMES*VMN*nI1LHqHaVanqlSGPXZzcfJ2lCmgq4zv7KspIBWFQN1fNpUVZWt6oPSTRucBuwPp3Sc10N0K4vTJe5462Z6RP*EJGxUu4QNsZcwgoNAuUGk0-7&new=1)

一般关于算法的文章，都是从经典算法讲起，一种一种算法介绍，见得算法多了，自然就有了感悟，但如此学习花费的时间和精力却是过于巨大，也不适合在博客里面交流。这一篇文，却是专门讲快捷思路的，很多人面对算法题的时候几乎是脑子里一片空白，这一篇文章讲的就是从题目下手，把毫无思路的题目打开一个缺口的几种常见技巧。

**（一）由简至繁**

事实上，很多问题确实是很难在第一时间内得到正确的思路的，这时候可以尝试一种由简至繁的思路。首先把问题规模缩小到非常容易解答的地步。

**[题目] 有足够量的 2 分、5 分、1 分硬币，请问凑齐 1 元钱有多少种方法？**

此题乍看上去，只会觉得完全无法入手，但是按照由简至繁的思路，我们可以先考虑极端简单的情况，假如把问题规模缩小成: 有足够量的 1 分硬币，请问凑齐 1 分钱有多少种方法？毫无疑问，答案是 1。

得到这一答案之后，我们可以略微扩大问题的规模： 有足够量的 1 分硬币，凑齐 2 分钱有多少种方法？凑齐 n 分钱有多少种方法？答案仍然是 1

接下来，我们可以从另一个角度来扩大问题，有足够量的 1 分硬币和 2 分硬币，凑齐 n 分钱有多少种方法？这时我们手里已经有了有足够量的 1 分硬币，凑齐任意多钱都只有 1 种方法，那么只用 1 分钱凑齐 n-2 分钱，有 1 种方法，只用 1 分钱凑齐 n-4 分钱，有 1 种方法，只用 1 分钱凑齐 n-6 分钱，有 1 种方法......

而凑齐这些 n-2、n-4、n-6 这些钱数，各自补上 2 分钱，会产生一种新的凑齐 n 分钱的方法，这些方法的总数 + 1，就是用 1 分硬币和 2 分硬币，凑齐 n 分钱的方法数了。

**在面试时，立刻采用这种思路是一种非常有益的尝试，解决小规模问题可以让你更加熟悉问题，并且慢慢发现问题的特性，最重要的是给你的面试官正面的信号——立即动手分析问题比皱眉冥思苦想看起来好得多。**

对于此题而言，我们可以很快发现问题的规模有两个维度：用 a1-ak 种硬币和凑齐 n 分钱，所以我们可以记做 P(k,n)。当我们发现递归公式 P(k,n) = P(k-1,n - ak) + P(k-1,n - 2*ak) + P(k-1,n - 3*ak) ... ... 时，这个问题已经是迎刃而解了

**通常由简至繁的思路，用来解决动态规划问题是非常有效的，当积累了一定量简单问题的解的时候，往往通向更高一层问题的答案已经摆在眼前了。**

**（二）一分为二**

另一种思路，就是把问题一刀斩下，把问题分为两半，变成两个与原来问题同构的问题，能把问题一分为 2，就能再一分为 4，就能再一分为 8，直到分成我们容易解决的问题。当尝试这种思路时，其实只需要考虑两个问题：1. 一分为二以后，问题是否被简化了？ 2. 根据一分为二的两个问题的解，能否方便地得出整个问题的解？

**[题目] 将一个数组排序。**

这个经典算法肯定所有人都熟悉的不能再熟悉了，不过若是从头开始思考这个问题，倒也不是所有人都能想出几种经典的排序算法之一的，这里仅仅是用来做例子说明一分为二的思路的应用。

最简单的一分为二，就是将数组分成两半，分别排序。对于两个有序数组，我们有办法将它合并成一个有序数组，所以这个一分为二的思路是可行的，同样对于已经分成两半的数组，我们还可以将这个数组分作两半，直到我们分好的数组仅有 1 个元素，1 个元素的数组天然就是有序的。不难看出，按这种思路我们得出的是经典数组排序算法中的 “归并排序”。

还有另一种一分为二的思路，考虑到自然将数组分成两半合并起来比较复杂，我们可以考虑将数组按照大于和小于某个元素分成两半，这样只要分别解决就可以直接连接成一个有序数组了，同样这个问题也是能够再次一分为二。按照这个思路，则可以得出经典数组排序算法中的 “快速排序”。

**（三）化虚为实**

这种思路针对的是浮点数有关的特殊问题，因为无论是穷举还是二分，对于浮点数相关的计算问题（尤其是计算几何）都难以启效，所以化虚为实，指的是把有点 "虚" 的浮点数，用整数来替代。具体做法是，把题目中给出的一些浮点数（不限于浮点数，我们不关心其具体大小的整数也可以）排序，然后用浮点数的序号代替本身来思考问题，等到具体计算时再替换回来。

**[题目]已知 n 个边水平竖直的矩形（用四元组 [x1,y1,x2,y2] 表示），求它们的总共覆盖面积。**

因为坐标可能出现浮点数，所以此题看起来十分繁复（可以实践上面由简至繁和一分为二的思路都基本无效），略一思考，矩形的覆盖关系其实只跟矩形坐标的大小有关，所以我们尝试思考将矩形的所有 x 值排序，然后用序号代替具体竖直，y 值亦然，于是我们得到所有矩形其实处于一个 2nx2n 的区块当中，这样我们用最简单的穷举办法，可以计算出每一个 1x1 的格子是否被覆盖住了。至此，只要我们计算面积的时候，把格子的真实长宽换算回来，就已经得到题目的答案了。

本文是某天在 QQ 群里讨论面试时的算法问题时想到要写的，以上三种思路，是我平时遇到算法问题的快速思考方向，并非万灵药方，若是不能生效，就要静下心来慢慢思考观察了，考虑到面试的时候基本不会遇到高难度算法题，这几种技巧的命中率应该不会太低，共享给大家，希望有所帮助。