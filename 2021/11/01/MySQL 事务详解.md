> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?src=11×tamp=1635736967&ver=3409&signature=ntSQ00F1XtS1B4Lefekd3I1TKng8DfOIU7nDfv3wfOqx2WvxRsksgpA9g1SB32slHAfohbIX38*EsUEvSYQ54-bI1Jr8-XLQGwyuv79P3RZR1T7AGG5FzyW9qytJj9XT&new=1)

> “
> 
> 今天无聊来撩一下 MySQL 事务，希望你们喜欢~

### 

目录

*   概念
    
*   隔离性与隔离级别
    
*   事务隔离的实现
    
*   事务启动方式
    
*   MVCC 工作原理
    
*   总结
    

一、概念
----

**事务**到底是什么东西呢？想必大家学习的时候也是对事务的概念很模糊的。接下来通过一个经典例子讲解事务。

银行在两个账户之间转账，从`A`账户转入 B 账户 1000 元，系统先减少 A 账户的 1000 元，然后再为`B`账号增加 1000 元。如果全部执行成功，数据库处于一致性；

如果仅执行完`A`账户金额的修改，而没有增加`B`账户的金额，则数据库就处于不一致状态，这时就需要取消前面的操作。

这过程中会有一系列的操作，比如**余额查询**，**余额做加减法**，**更新余额**等，这些操作必须保证是一个整体执行，要么**全部成功**，要么**全部失败**，不能让`A`账户钱扣了，但是中途某些操作失败了，导致`B`账户更新余额失败。这样用户就不乐意了，银行这不是坑我吗？

> “
> 
> 事务就是要保证一组数据库操作，要么全部成功，要么全部失败。

在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。

二、隔离性与隔离级别
----------

1.  **读未提交**（read uncommitted）
    
2.  **读提交**（read committed）
    
3.  **可重复读**（repeatable read）
    
4.  **串行化**（serializable ）
    

1.  **读未提交**：事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，也被称为`脏读`。这个级别会导致很多问题，从性能上来说也不会比其他隔离级别好很多，但却缺乏其他级别的很多好处，一般实际应用中很少用，甚至有些数据库内部根本就没有实现。
    
2.  **读已提交**：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，这个级别有时候也叫做`不可重复读`（Nonrepeatable Read）, 因为同一事务中两次执行同样的查询，可能会得到不一样的结果
    
3.  **可重复度**：同个事务中多次查询结果是一致的，解决了不可重复读的问题。此隔离级别下还是无法解决另外一个`幻读`（Phantom Read）的问题，幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，之前的事务再次读取该范围的记录时，会产生幻行
    
4.  **串行化**：顾名思义是对于同一行记录，`写`会加`写锁`，`读`会加`读锁`。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
    

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlFbCjn7hibNxCY1PhA7eVMAjU0WbUibewymCu15BHlRnVzeuCE2fyk1Wg/640?wx_fmt=png)

1.  若隔离级别是**读未提交**， 则`V1`的值就是`2`。这时候`事务B`虽然还没有提交，但是结果已经被`A`看到了。因此，`V2`、`V3`也都是`2`。
    
2.  若隔离级别是**读提交**，则`V1`是 1，`V2`的值是 2。`事务B`的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
    
3.  若隔离级别是**可重复读**，则`V1`、`V2`是 1，`V3`是 2。之所以`V2`还是 1，遵循的就是这个要求：**事务在执行期间看到的数据前后必须是一致的**。
    
4.  若隔离级别是**串行化**，则在`事务B`执行 “将 1 改成 2” 的时候，会被锁住。直到`事务A`提交后，`事务B`才可以继续执行。所以从`A`的角度看， `V1`、`V2`值是 1，`V3`的值是 2。
    

在**读提交**隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，**读未提交**隔离级别下直接返回记录上的最新值，没有视图概念；而**串行化**隔离级别下直接用加锁的方式来避免并行访问。

注意一下，每种数据库的行为会有所不一样，`Oracle`数据库的默认隔离界别是**读提交**，因此，当我们需要进行不同数据库种类之间迁移的时候，为了保证数据库隔离级别的一致，切记将 MYSQL 的隔离级别设置为**读提交**。

配置的方式是，将启动参数`transaction-isolation`的值设置成`READ-COMMITTED`。你可以用`show variables`来查看当前的值。

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2Plfr0WX8bCHo1Pq15xeWZLLibu3UaDgjia9foQGKDTCOMBCUseggNJzSbw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PltnnicUr1zSFqDZBXr7xSbHBwjfNsRCbtK5cwttH7cFYvicg7UtF84sJQ/640?wx_fmt=png)

每种隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要 “可重复读” 的场景呢？我们来看一个数据校对逻辑的案例。

假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

这时候使用**可重复读**隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

三、事务隔离的实现
---------

接下来以可重复度来展开事务隔离具体是怎么实现的。

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlER2kR8LfmDiacWvwGVQVR7F7fI2GEUicetXL6tg9PFWA3LpJgVhJeVHA/640?wx_fmt=png)

可以看到当前值是 4，从图中可以看到在查询的时候，不同时刻启动的事务会有不同的`read-view`。如图中看到的，在视图`A`、`B`、`C`里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。

对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？

这是肯定不能一直保留的，在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

那么什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的`read-view`的时候。

基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在`MySQL 5.5`及以前的版本，回滚日志是跟数据字典一起放在`ibdata`文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有`20GB`，而回滚段有`200GB`的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

四、事务启动方式
--------

MySQL 的事务启动方式有以下几种：

1.  显式启动事务语句， `begin` 或 `start transaction`。配套的提交语句是`commit`，回滚语句是`rollback`。
    
2.  `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个`select`语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行`commit` 或 `rollback` 语句，或者断开连接。
    

有些客户端连接框架会默认连接成功后先执行一个`set autocommit=0`的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此，我会建议你总是使用`set autocommit=1`, 通过显式语句的方式来启动事务。

但是有的开发同学会纠结**多一次交互**的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 `begin`，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用`commit work and chain`语法。

在`autocommit`为 1 的情况下，用`begin`显式启动的事务，如果执行`commit`则提交事务。如果执行 `commit work and chain`，则是提交事务并自动启动下一个事务，这样也省去了再次执行`begin`语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60


```

五、MVCC 工作原理
-----------

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlIoibVoLcxbXKZQSgyjRqQst3cOnEgmhKuQbbFt20asHCzCBhXBd6jEA/640?wx_fmt=png)

当然，如果 “上一个版本” 也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在 “活跃” 的所有事务 ID。“活跃”指的就是，启动了但还没提交。

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

这个视图数组把所有的 row trx_id 分成了几种不同的情况。如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlRPOVLRMQ8Djbc6WXw20ILn5I4mWcgXLC2VA24elasTC1gKbQpibsRGA/640?wx_fmt=png)

上图是数据库版本可见性规则，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1.  如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
    
2.  如果落在灰色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
    
3.  如果落在粉色部分，那就包括两种情况
    

*   (a) 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    
*   (b) 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
    

比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 21，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。

你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的 2 或者 3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是 “静态” 的了。

所以你现在知道了，InnoDB 利用了**所有数据都有多个版本**的这个特性，实现了 “秒级创建快照” 的能力。

接下来我们用一个例子来巩固一下 MVCC 的知识，例子如下：

下面是一个只有两行的表的初始化语句。

```
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);


```

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2Pl8Rmk9sH2mY5E70DZfHFfuy5oMluDHVibbMSk3DYL4PrWAwSRICWSDFw/640?wx_fmt=png)

`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用`start transaction with consistent snapshot` 这个命令。

还需要注意的是，我们的例子中如果没有特别说明，都是默认`autocommit=1`。

在这个例子中，事务 C 没有显式地使用`begin/commit`，表示这个`update`语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。

让我们想一下图中的三个事务，分析一下事务 A 的语句返回的结果是什么？

答案：**事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1**，是不是感到有点奇怪？

接下来我们用假设分析法，进行如下的假设：

1.  事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
    
2.  事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
    
3.  三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。
    

这样，事务 A 的视图数组就是`[99,100]`, 事务 B 的视图数组是`[99,100,101]`, 事务 C 的视图数组是`[99,100,101,102]`。

为了便于我们分析，接下来我们通过一个图去分析，如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2Pl5Bpbiblkc5HhM3G5JH26ggPaCJr6xZEh1JCKRmpIcZCsNwcBUlX0NkA/640?wx_fmt=png)

这里需要说明一下，`start transaction with consistent snapshot;`的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的`start transaction`。

从图中可以看到，第一个有效更新是事务 C，把数据从`(1,1)`改成了`(1,2)`。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。

第二个有效更新是事务 B，把数据从`(1,2)`改成了`(1,3)`。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。

你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。

好，现在事务 A 要来读数据了，它的视图数组是`[99,100]`。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：

1.  找到`(1,3)`的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；
    
2.  接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；
    
3.  再往前找，终于找到了`（1,1)`，它的 row trx_id=90，比低水位小，处于绿色区域，可见。
    

这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。

这个判断规则是我通过一些资料和高性能 MYSQL 中从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1.  版本未提交，不可见；
    
2.  版本已提交，但是是在视图创建后提交的，不可见；
    
3.  版本已提交，而且是在视图创建前提交的，可见。
    

现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：

*   `(1,3)`还没提交，属于情况 1，不可见；
    
*   `(1,2)`虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；
    
*   `(1,1)`是在视图数组创建之前提交的，可见。
    

你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。

这时候你是不是有一个这样的疑问：事务 B 的`update`语句，如果按照一致性读，好像结果不对哦？

事务 B 的视图数组是先创建的，之后事务 C 才提交，不是应该看不见`(1,2)`吗，怎么能算出`(1,3)`来？

确实如此，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。

但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。

因此，事务 B 此时的`set k=k+1`是在`（1,2）`的基础上进行的操作，这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为 ** 当前读。

因此，在更新的时候，当前读拿到的数据是`(1,2)`，更新后生成了新版本的数据`(1,3)`，这个新版本的 row trx_id 是 101。所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。

这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。

因此，如果把事务 A 的查询语句`select * from t where id=1`修改一下，加上`lock in share mode` 或 `for update`，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。

```
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;


```

假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlsAJVslxV8vTWEQYibsNqOv9Mz1oceZRwQ2AINETwJDuZPLwU7fqnNPA/640?wx_fmt=png)

事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是`(1,2)`这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？

这时候，我们的**两阶段锁协议**就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。

那么回到之前的隔离界别中的事务的可重复读的能力是怎么实现的？

**可重复读的核心就是一致性读（consistent read）**；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

1.  在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
    
2.  在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。
    

接下来再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/udLqq2icv6rPyRueFePRGVuIT6oCKA2PlCGLxzicas4T8ibicicsY39MumPx92Se3677ussOXG4U8uTVct4PeCaNgZQ/640?wx_fmt=png)

可以看到此时事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时间线上`(1,2)`、`(1,3)`的生成时间都在创建这个视图数组的时刻之前。

但是，在这个时刻：`(1,3)`还没提交，属于情况 1，不可见；`(1,2)`提交了，属于情况 3，可见。所以，这时候事务 A 查询语句返回的是 k=2。显然地，事务 B 查询结果 k=3。

六、总结
----

本文从底层分析了 MySQL 的事务原理，希望对你们有所帮助，最后别忘了点赞哟！！！

干货分享
----

> 最近将个人学习笔记整理成册，使用 PDF 分享。关注我，回复如下代码，即可获得百度盘地址，无套路领取！
> 
> •001：《Java 并发与高并发解决方案》学习笔记；•002：《深入 JVM 内核——原理、诊断与优化》学习笔记；•003：《Java 面试宝典》•004：《Docker 开源书》•005：《Kubernetes 开源书》•006：《DDD 速成（领域驱动设计速成）》•007：**全部** •008：**加技术群讨论**

近期热文
----

•[LinkedBlockingQueue vs ConcurrentLinkedQueue](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487352&idx=2&sn=4b5f6d7d1bfc3d1873ff3c4a40fa61e2&chksm=ec3c921fdb4b1b09c759666a935b962dbefa682ca7283bed00bffafded7c3e3ad97e8b5db91e&scene=21#wechat_redirect "LinkedBlockingQueue vs ConcurrentLinkedQueue")• [解读 Java 8 中为并发而生的 ConcurrentHashMap](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487340&idx=2&sn=ca55c4a3a20bf6ad69f6bd78b39f20c2&chksm=ec3c920bdb4b1b1dae5bcb53d41addad66057f3915e02f9f9453cf9a8cc9a8ffc1802208ff5d&scene=21#wechat_redirect "解读Java 8 中为并发而生的 ConcurrentHashMap")•[Redis 性能监控指标汇总](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487333&idx=1&sn=024a6ccd4a3d76a71709bfd073a1a8f5&chksm=ec3c9202db4b1b14180ba23f9e69c769642d5ad6a87ac00534ca522844f148bb47ee95bee4fd&scene=21#wechat_redirect "Redis性能监控指标汇总") • [最全的 DevOps 工具集合，再也不怕选型了！](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487325&idx=2&sn=f961237a5b0712b1aaa5bb21ce043a61&chksm=ec3c923adb4b1b2cbc17dd6ed15e1db1e01e39ad8a6a9f7d8250637783cda76c3f0964f2aa24&scene=21#wechat_redirect "最全的DevOps工具集合，再也不怕选型了！")• [微服务架构下，解决数据库跨库查询的一些思路](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487290&idx=1&sn=56c258ef320c3e4b913e8f4babf1ead4&chksm=ec3c925ddb4b1b4bd8200b86b6a971964029b9976d9162a98584b20769232acd0a9317ad3ba1&scene=21#wechat_redirect "微服务架构下，解决数据库跨库查询的一些思路") • [聊聊大厂面试官必问的 MySQL 锁机制](https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&mid=2247487287&idx=1&sn=dd569b120939b3d0222435a8402c7fba&chksm=ec3c9250db4b1b4646ce8d845a5d8d9206b863d3b2d0f3481b4e8fdfe1fd3ea493e31fdfcbf2&scene=21#wechat_redirect "聊聊大厂面试官必问的 MySQL 锁机制")

关注我
---

![](https://mmbiz.qpic.cn/mmbiz_jpg/C93dCHmGrWy1MeSCFn1S6T6v1CEmUNjAXQsaTeibgWqCIDpuVAsEkDESMeaWibFY9b0ZSIDznsd5vlsOLGt3c6uQ/640?wx_fmt=jpeg)

喜欢就点个 "在看" 呗 ^_^