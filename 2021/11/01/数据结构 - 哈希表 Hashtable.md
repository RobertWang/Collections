> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/51852513)

设想我现在想往一个 Symbol Table 里储存一系列 key-value 对：

名字（Key） 分数（Value）

Sam 58 分

Tom 40 分

Steve 60 分

Chris 63 分

我们当然可以用红黑树或是普通的 BST 来存储，但是还有一个思路。

我们知道数组这个东西的特点是可以在 O（1）的时间内获取数组中的任何一个指定元素，比如我创建一个长度为四的整数数组：

int a[4];

那我是不是可以把上面的四个人的分数存到这个数组里？

就像这样：

a[0] = 58 a[1] = 40 a[2] = 60 a[3] = 63

存进来了是吧？然后呢？

我们希望通过 “名字” 来找到 “分数”，也就是要有一个函数或是映射，从“名字“映射到” 分数“，就像这样：

f（Sam） = 58

f （Tom） = 40

...

没错吧？

我们看，我们现在已经建立了从数组角标（index）到数组的值（考试分数）的映射：

g（0）= 58

g（1） = 40

...

也就是说，我们再需要一个从名字到数组角标的映射就好了！

也就是：

h（Sam）= 0

h（Tom）= 1

...

这样的话，h 映射和 f 映射复合之后就是 f 映射。

g（h（Sam）） = 58

g （h（Tom）） = 40

那我们就先做一个函数，将四个人的名字转换成数组角标，这个函数本质就是刚刚的 h。

public int h（String s) {

if (s == Sam) { return 0 ;}

if (s == Tom）{ return 1;}

if (s == Steve) { return 2; }

if (s == Chris) { return 3; }

}

就这样，到此为止，我们就完成了一个哈希表，到时候，我们只需这样提取某个学生的成绩：

a[h(Sam)] = a[0] = 58

理解了么？

所以说，**Hashtable 的核心问题是，研究如何把这些 key 转化成数组角标。**

刚刚的仅仅是几个人，要是几万个人呢？我们就要建立一个可以运算的哈希函数来讲特定类型的 Key 转化成数组角标。

比如 Key 是学号，像这样：

PB 16254825

我们要存储姓名，Value 的类型是 String。

然后大概有 2000 个学生，所以我们可以创建一个长度为 2000 的数组：String a[2000]。

然后我们只剩下如何构建哈希函数（Hash Function) 了。

我们希望学号转换成数组角标后，这些数组角标经可能随机均匀地分散在 [0, 1999] 这个区间内，尽可能不要出现两个学生对应的数组角标相等（如果相等，我们有处理办法，先不去管他）。

如果选取学号的前三位数字作为数组角标怎么样？

答案是肯定不行，因为这是 16 届学生，大家学号开头两位都是 16，所以最后数组角标都在 [160, 169] 内了，肯定不行。

取余运算的结果天生就在 [0, 被取余 - 1] 范围内。

比如：1%4 = 1，34%4 = 2，etc.

对于任意整数 k，k%M = 0 or 1 or 2 or 3 or ... M - 1;

所以我们选择对学号整个关于 2000 取余！

这样基本上很舒服，均匀分布在了 [0, 1999] 内，但是出现一个问题就是，有个别两个同学的数组角标一样：

比如 PB 16254825 （Sam）和 PB 16256825 （Steve），它们关于 2000 取余都是 825。

对于这种情况，我们称之为 Collision，就是” 撞在一块儿 “了。

我们发现其实无伤大雅，只需让数组里的数作为一个链表的表头就好了，也就是说，a[825] 本身可以是一个链表的表头，然后 a[825] = Sam，a[825].next = Steve。

其实这样的话，也只是稍微增加了寻找一个 Value 的时间而已，无伤大雅~

接下来，我们来看看 Java 的 java.util 源码中 Hashtable 是怎样实现的：

带大家读一下。

直接打开，跳转至 put（）方法：

472 行的 synchronized 关键字表示该方法不能被多个线程同时调用，而是一个线程用完再下一个，依次来，这样子，不懂没关系。

474 - 476 行 如果 value == null，就 throw 一个 exception，表示不允许传递 null。

479 行：让 tab[] 指向哈希表的指针（table 是哈希表的那个数组本体），而这个数组的类型是 Entry<?, ?> 类型的，Entry 是自定义的一个类，它包含 key 和 value，还有一些别的变量。

480：hashCode 方法。

注意: hashCode 本身并不是 hash function，hash funciton 是把 key 直接转换成数组坐标，而 hashCode 是把 key 转换成一个在 int 范围内的数，[-2^31, 2^31-1]，然后我们再对这个 hashCode 取余，生成数组坐标。

也就是说并不是所有的 key 都像学号那样，本身是个整数，有的是 String，比如”Sam“，这时你要把 Sam 转换成一个整数，也就是 hashcode，再对 hashcode 进行取余，生成 index（数组坐标）。

483：把哈希表中的第 index 个 entry 赋给”entry“，便于一会儿操作。

484 - 490：这个循环你在哪见过？在链表里吧？当插入的 key 已经在 table 中存在时，也就是 if 语句为真时，我们把原先 key 对应的 value 进行重写，写成我们传入的 value。

如果没有的话，循环结束，调用 addEntry 方法，表示在 table【index】这个链表里插入一个新的 entry，该 entry 的 key，value 为用户传入的，hash 即为 hashcode，是算出来的。

那有些同学肯定会问了，万一我要插入的 key-value 对特别多，多处预期呢？也就是说，我现在的 table【】只有 500 个位置，结果要插入 50000 个 key-valuepair，那么平均每个 entry 就要平摊 100 个 key-valuepair，这样就增大了我们寻找的时间。

于是我们怎么办？当然是 resize 了，就像我们原来在 resizing array 中学到的一样，当元素填满数组时，就扩增数组。

那对于 hashtable 来讲，我们引入一个 loadfactor，” 载入因子 “，就是当总的 key-value 对的个数 乘上这个 loadfactor> table.length 时，我们就把 table 的容量扩充两倍。

这个 loadfactor 是个（0，1）的浮点数，其实很好理解，比如 loadfactor 是 0.5，那么当 key-value 对个数是 table 数组长度的两倍时，就扩充。

一般默认为 0.75，如果 loadfactor 选的太小，会增大检索时间，但是同时节省内存，选的太大，内存浪费多。

该方法是 rehash（）：

![](https://pic2.zhimg.com/v2-617023715528d3d1c80641f77df5f8e9_b.jpg)

自行阅读~

有不懂的可以私信作者本人。

就这样。