> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/363452939)

1. 背景

  
上一篇文章中提到过，小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

  
即「静默登录」，通过调用 `wx.login` 获取到 `code` ，将其发送到开发者后端，开发者后端通过接口去微信后端换取到 `openid` 和 `sessionKey`（现在会将 `unionid` 也一并返回）后，然后把自定义登录态 `3rd_session`(本业务命名为`auth-token`) 返回给前端，就已经完成登录行为了。

  
理论上，开发者后端可以通过 `openid`识别用户，也能通过`unionid`关联同主体的多个小程序、公众号、app，实现数据互通，从而为每一个用户创建独一无二的`uid`（本业务自定义的用户 id），在「微信生态」中建立成熟用户体系。

  
然而，对于复杂的电商跨端应用，比如`pc`、`h5`、`小程序`，不同渠道注册的`uid`是不同的，用户登录后**难以对各个渠道的交易、促销、收藏等数据进行整合**。因此，要实现跨端的用户体系数据互通，就需要提供一个唯一的用户标识——**手机号**。这便是本文重点讲述的「用户登录」，即「游客态」转变成「会员态」的过程。

  
2. 「用户登录」流程
--------------

  
当新用户第一次进入小程序时，便会触发「静默登录」，这个过程**对用户是无感知的**。但此时开发者服务端已经为该用户定义了`uid`，并下发`auth-token`给小程序端，对于一些需要鉴权的请求，服务端可以根据请求携带的`auth-token`精确识别是哪个用户发起的行为。

  
然而，类似`加购`、`下单`、`领券`等用户行为，涉及到跨端数据的整合，在执行用户操作之前，会判断用户是否登录，如若用户未登录，则跳转登录页面，整个流程如下所示：  

![](https://pic4.zhimg.com/v2-87ff289c77d4906c8dff39a36c32566b_b.jpg)

比如在「用户中心」页面点击「我的订单」，由于此时用户未登录，跳转到登录页面，可以选择以下两种登录方式：  

*   选择 **「微信授权登录」**，弹出授权手机号信息弹窗，点击「允许」，此时用户登录成功。
*   选择 **「手机快捷登录」**，输入手机号，使用 **「验证码」** 或者 **「密码」** 进行登录，登录成功跳转回到「用户中心」页面。

上述步骤**已经完成了「用户登录」，用户可以正常的执行加购、领券、下单等操作**。 为了提升用户体验，需要对 **「会员信息」** 进行维护 ，比如昵称、头像、性别、生日等信息，最简单的方法是 **获取「微信授权用户信息」**。触发时机分为以下两种：  

*   用户第一次选择 **「微信授权登录」** 成功后跳转授权用户信息页面，点击 **「授权用户信息」**，弹出授权用户信息弹窗。点击「允许」，跳转回「用户中心」页面。
*   在「用户中心」页面点击头像昵称区域，弹出授权用户信息弹窗，点击「允许」，更新「会员信息」并跳转用户信息编辑页面。

3. 「用户登录」方案设计
-------------

  
3.1 架构  

![](https://pic2.zhimg.com/v2-cc71e1e42ee08811d9c9c1bbce94a591_b.jpg)

「用户登录」方案架构如上图所示，将所有登录相关功能抽象到 **「service 层」**（本项目将其命名为`session`），供 **「业务层」** 调用。该 **「service 层」** 主要分为以下两个模块：  
3.1.1 `libs` - 提供登录相关的类方法供「业务层」调用  

1.  封装`session`类，提供类方法供「业务层」调用。主要有以下几种方法：

![](https://pic2.zhimg.com/v2-58faed7e0f49932fdcd65af2002c14bd_b.jpg)

当然，`session`类中还封装了一些方法用于与`storage`交互，比如获取`storage`中的`auth-token`用于各种鉴权请求携带等等。`session`类也提供的一些拓展方法，比如注销账号、解绑手机号等等用于后续需求迭代。  

1.  装饰器：  
    

*   **`must-auth`**： `mustAuth`类方法的装饰器，便于业务层各种场景触发登录。
*   **`fuse-line`**： **熔断机制**，如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。用于解决`refreshLogin`、`login`等方法的并发处理问题。
*   **`single-queue`**： **单队列模式**，同一时间，只允许一个正在过程中的网络请求。请求被锁定之后，同样的请求都会被推入队列，等待进行中的请求返回后，消费同一个结果。用于解决`refreshLogin`、`login`等方法的并发处理问题。

3.1.2 `ui` - 提供通用组件供业务层调用  

*   **基础组件**： `user-container`和`phone-container`分别是获取「微信授权用户信息」和获取「微信授权手机号」的纯 UI 单元组件，给通用组件使用。
*   **behavior 类**：拿到授权数据后需要发送给服务端进行存储，也需要执行一些跳转逻辑判断，这些都抽象成行为类封装在`auth-flow`中，供通用组件使用。
*   **通用组件**： 共用一个行为类，区别在于`auth-flow-container`用于页面，`auth-flow-popup`用于弹窗。如下所示，小程序只有微信授权功能，则可以通过弹窗完成授权。如小程序同时提供手机号验证码和密码登录等功能，则需跳转特定登录页面。

![](https://pic1.zhimg.com/v2-3875351d26b53b386f1e07e0849ca064_b.jpg)

3.2 libs

  
3.2.1 用户身份定义  

![](https://pic4.zhimg.com/v2-5a51782055514b9b6c0cbfd1301d8e13_b.jpg)

综上所示，用户登录的阶段可以分为以下三步：

![](https://pic2.zhimg.com/v2-6267b9502e760833bd3b43f685dcc6f9_b.jpg)

  
那么如何判断用户此时处于哪个步骤，基于「静默登录」的启发，原本「静默登录」成功开发者后端会将自定义登录态 `auth-token`返回给前端，此处请求可以携带返回「用户信息」，同`auth-token`一起命名为`session`存储在本地`storage`。**当「用户登录」或者「更新用户信息」时，会同步更新`storage`中`key`为`session`的数据，从而通过这些用户数据判断当前用户处于哪一个登录阶段**。

  
以下表格列出了`session`存储的部分重要的属性以及在三个阶段属性对应的值。

![](https://pic2.zhimg.com/v2-c97aeb9f70dd8da999feec065a98c29d_b.jpg)

**注意：** 会员态和会员信息态的`busiIdentity`值均为`MEMBER`，区分会员态和会员信息态可以通过用户昵称和头像等字段，比如用户登录成功会为用户生成以'u_'开头的默认昵称和默认为空的用户头像链接。

  
判断用户此时处于哪个步骤的代码如下：

![](https://pic3.zhimg.com/v2-fdd8710a80a879230a6a4d0809eb84b6_b.jpg)

  
3.2.2 用户登录触发场景

  
前面提到过，「用户登录」的 **目的是为了整合各个渠道的交易、促销、收藏等数据**，针对电商小程序，目前总结的需要用户登录的场景如下所示：  

![](https://pic1.zhimg.com/v2-bdd20fef9a6e76d677ea1400763d796c_b.jpg)

即当用户登录小程序时，可以正常浏览浏览商品，**只有触发某些特定行为，比如领券、加购、收藏、下单等，才会判断用户是否处于登录状态，如未登录，跳转登录页面**。

  
如下所示，封装`mustAuth`方法进行拦截，未登录则跳转登录页面：

![](https://pic3.zhimg.com/v2-380b9100a30a728265aed35cbdce5c1e_b.jpg)

上述代码是跳转页面拦截，对于弹窗而言，需要把弹窗注入`base-page`(每个页面都需要引入的通用组件，封装每个页面都需要使用的通用方法，比如错误处理等) 中，通过 id 查找到弹窗组件，并进行调用。

![](https://pic1.zhimg.com/v2-828f7e882f83d351b113070a159f3828_b.jpg)

各个业务使用时可以通过`session.mustAuth().then(() => {...});`进行调用，为了提高使用体验，也可以使用装饰器`@mustAuth()`来修饰各个业务需求 **类的方法**，装饰器源码如下：

![](https://pic4.zhimg.com/v2-d642e3598b1b365bf8503190f1858063_b.jpg)

  
3.3 UI

  
3.3.1 基础组件

  
**1. phone-container 组件**

  
因为需要用户主动触发才能发起获取微信授权手机号接口，需用 `button` 组件的点击来触发。组件代码如下所示：

```
 // index.wxml  
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber" hover-class="none" disabled="{{disabled}}"><slot></slot></button>  
// index.ts 
export default class PhoneContainer extends BaseComponent {   getPhoneNumber(     e: WechatMiniprogram.Event<WechatMiniprogram.GetPhoneNumberCallbackResult>,   ) {     this.triggerEvent('getphonenumber', { ...e.detail,  authType: AuthType.PHONE,});   } } 

```

`phone-container`是一个纯 UI 组件，通过`triggerEvent`事件将获取手机号数据传递给父组件，

  
**2. user-container 组件**

  
`user-container`组件是获取微信授权用户信息的纯 UI 组件，之前通过`<button open-type="getUserInfo" bindgetUserInfo="getUserInfo"/>`的方式进行获取。2021 年 2 月 23 日，微信团队发布了[《小程序登录、用户信息相关接口调整说明》](https://link.zhihu.com/?target=https%3A//developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801%3Fsource%3Dindexnew)，新增`getUserProfile`接口替代原来的`wx.getUserInfo`，来获取用户头像、昵称、性别及地区信息，也是通过`button` 组件的点击来触发。两者的区别如下图所示：  

![](https://pic3.zhimg.com/v2-e0b0ae196da1621ff1ee2c413b9a108e_b.jpg)

2012 年 4 月 13 日之前，使用`wx.getUserInfo`弹出授权弹窗时，如果用户点击允许授权，那么会记录用户的行为，下次再点击时，**不会弹窗**而是直接将授权结果返回。4 月 13 日之后后，使用`wx.getUserProfile`，**开发者每次通过该接口获取用户个人信息均需用户确认，因此需要妥善保管用户授权的头像昵称，避免重复弹窗。**  
3.3.2 行为类  
如下图所示，`auth-flow`行为类主要封装用户、小程序、服务端三者之间的交互逻辑。  

![](https://pic3.zhimg.com/v2-b687aece62a396d3a72adf0625dfde5a_b.jpg)

在「微信授权登录」过程中，小程序拿到加密的`encryptedData`和`iv`数据，将其和携带的`auth-token`一起发送给开发者服务器，服务端通过`auth-token`鉴权识别这个用户，并使用静默登录成功获取的`session_key`（对称解密密钥）对`encryptedData`和`iv`数据进行对称解密，获取该用户的手机号，将手机号与`uid`绑定，此时该用户成功注册会员，并将会员信息返回给小程序端。

  
小程序端更新本地`storage`存储的`session`数据，此时`busiIdentity`的值已经从`VISIT`更新为`MEMBER`，用户身份转变为**会员态**，登录成功。

  
在「授权用户信息」的过程中，小程序调用`wx.getUserProfile`方法拿到用户数据，并将这些数据与携带的`auth-token`一起发送给开发者服务器，服务端通过`auth-token`鉴权识别这个用户，更新该用户的信息并将新的会员数据返回给小程序端。

  
小程序端更新本地`storage`存储的`session`数据，此时用户昵称和头像均已更新，用户身份转变为**会员信息态**，授权成功。

  
眼尖的读者一定观察到了，时序图中还对微信头像做了转存。这是因为**用户在微信端修改微信头像后，之前「授权用户信息」获取的微信头像链接就会失效**，因此开发者应该在自己获取用户信息后，将头像保存下来，避免微信头像 URL 失效后的异常情况。

  
3.3.3 通用组件

  
通用组件是对基础组件和行为类的二次封装，主要是为业务层提供弹窗登录和页面登录两种能力。

  
4. 总结

  
我们将用户登录能力从业务层中抽象出来，统一封装在`service`层，便于复用。本文主要讲述的是`service`层的架构，对于业务层的逻辑实现并没有多加累赘。下列表格以小程序端为例，简述了「静默登录」和「用户登录」整套方案的前后端逻辑实现。  

![](https://pic1.zhimg.com/v2-3bf2641118eb20e81eb964492cb9cb98_b.jpg)![](https://pic1.zhimg.com/v2-376319b54d523d6ff5068de53122357c_b.jpg)

作者水平有限，敬请指教～ **码字不易，如果您觉得有帮助，点个赞再走呗~**

> 作者：蔡小真，_著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。_

想要学习更多精彩的实战技术教程？关注微信公众号：极乐技术社区

![](https://pic2.zhimg.com/v2-d8ef030690660225181d6fb69e63be21_b.jpg)