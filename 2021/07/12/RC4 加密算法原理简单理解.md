> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/gambler/p/9075415.html)

学了这么多加密算法，首先要了解的是：对明文使用同一个密钥异或两次最后是得到原文的

RC4 加密算法其实也是比较简单的，重点是在秘钥流生成器那里，其实也是比较简单的。

重点讲解 RC4 秘钥生成步骤

感觉这个流程图画的很不错，拿过来作为大家参考一下（图片转载地址：https://www.cnblogs.com/block2016/p/5601925.html）

![](https://images2015.cnblogs.com/blog/929265/201606/929265-20160620213652444-560250478.jpg)

1、先初始化状态向量 S（256 个字节，用来作为密钥流生成的种子 1）

按照升序，给每个字节赋值 0,1,2,3,4,5,6.....,254,255

2、初始密钥（由用户输入），长度任意

如果输入长度小于 256 个字节，则进行轮转，直到填满

例如输入密钥的是 1,2,3,4,5   ,  那么填入的是 1,2,3,4,5,1,2,3,4,5,1,2,3,4,5........

由上述轮转过程得到 256 个字节的向量 T（用来作为密钥流生成的种子 2）

3、开始对状态向量 S 进行置换操作（用来打乱初始种子 1）

按照下列规则进行

从第零个字节开始，执行 256 次，保证每个字节都得到处理

　j = 0;

　　for (i = 0 ; i < 256 ; i++){

　　　　j = (j + S[i] + T[i]) mod 256;

　　　　swap(S[i] , S[j]);

　　}

这样处理后的状态向量 S 几乎是带有一定的随机性了

4、最后是秘钥流的生成与加密，很多人在这里不是特别理解，别的博客也没有写的很简洁明了

假设我的明文字节数是 datalength=1024 个字节（当然可以是任意个字节）

i=0;

j=0;

while(datalength--){// 相当于执行 1024 次，这样生成的秘钥流也是 1024 个字节

　　　i = (i + 1) mod 256;

　　　　j = (j + S[i]) mod 256;

　　　　swap(S[i] , S[j]);

　　　　t = (S[i] + S[j]) mod 256;

　　　　k = S[t]; 这里的 K 就是当前生成的一个秘钥流中的一位

　　　　// 可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就 ok

　　　　data[]=data[]^k； // 进行加密，"^" 是异或运算符

}

解密按照前面写的，异或两次就是原文，所以只要把密钥流重新拿过来异或一次就能得到原文了

这样就完成了一次生成密钥流及加密的过程，这也是 RC4 的全部工作，是不是很简单呢？