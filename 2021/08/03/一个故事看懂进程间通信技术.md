> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/xuanyuan/p/15078280.html)

月黑风高夜，突然听得咣当一声，Web 服务器的目录下冒出了两个文件，弄出了不小的声响。这两个家伙一胖一瘦，鬼鬼祟祟，潜入这台计算机，不知要搞什么名堂。

“二弟，一会儿咱们按照计划好的运行起来，分头行事，你等我信号，拿到数据后赶紧撤”，胖子对瘦子说到。

“老大，这地方我不熟悉，我怎么等你信号？咱们得想个联系方式，一会儿通信使用”，瘦子说到。

“这个不用担心，主人都交代好了”，胖子一边说，一边从背后拿出一本 **《Linux 进程间通信手册》** 翻了起来。

信号
--

翻开手册的第一页，上面写着：**信号——Signal**，两个家伙开始认真研究起来。

片刻之后，胖子程序说道：“唉，这个不行，往后翻吧！”

瘦子程序不解，问道：“咋就不行啦？”

“你看这里，手册上说了，信号是 Linux 上的一种**软中断**通信机制，可以向指定进程发送通知，总共有 64 种信号，不过这个信号只能作为通知使用，没办法传输数据”

![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730095922585-660344932.png)

“没法传输数据？那这玩意有什么用？”

“还是有用啊，可以通知某个进程发生了什么事件，比如 kill 命令就是利用这个信号来告知进程退出从而实现杀进程的效果的”

“原来如此”，瘦子程序若有所思的点了点头，此时胖子已经翻到了手册的第二页。

socket
------

“你看，手册上写了，可以用 **socket**”，胖子说到。

“socket？那不是网络通信使用的吗？”，瘦子有些疑惑。

“是啊，不过咱们一样可以用来在本地计算机通信，把连接的 IP 地址换成 127.0.0.1 就行了”

“感觉有点太招摇了，咱们计算机内部进程通信，数据还要经过网卡，很容易被发现的！”

“不会不会，手册上说了，127.0.0.1 是本地回环地址，数据在协议栈就进行转发了，根本不会到达网卡”

![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730095935122-1067676259.png)

“那抓包能抓到咱们通信吗？”

“嗯，让我看看 ··· 手册上说，可以在虚拟的回环网卡 **lo** 上抓到数据”

“还是算了吧，咱干这事得悄悄进行，不能留下痕迹，你再看看还有没有别的招”

听瘦子这么一说，胖子倒也觉得有理，便在手册上继续翻了起来。

匿名管道
----

“哎，有了有了，这个叫**匿名管道**的，听起来就比较隐秘，应该不会被发现。”

瘦子接过手册，看了起来。

这俩盯着手册上的两个图研究了半天，总算弄明白了，所谓匿名管道不过是内核中的一段缓冲区，提供了读写两个口子，通过 fork 创建子进程后，子进程继承了父进程的管道信息，两边只要约定好，一个读，一个写，就能实现通信了。

![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730095952828-1845230846.png)

 ![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730100002530-1642947234.png)

“老大，这匿名管道是单向的，咱们要通信，得整两根管道才行，一个你写我读，一个我写你读”

“看起来挺靠谱，就这么干！”，二人达成了一致。

胖子程序率先运行起来，随后创建了两个管道，一个用来发送消息，一个用来接收消息。接着执行 fork，将瘦子程序也运行了起来。

![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730100014913-2103269103.png)

时间过的很快，转眼已是深夜，随着计算机被关掉，两个家伙的进程也都退出了。

半夜无人之际，硬盘中这两个家伙开始吵起来了。

“你是怎么回事？我给你发消息怎么也不回，害得我一连发了一堆消息，最后把管道塞满了，我都阻塞了！”，胖子程序气愤地说道。

“嗨！别提了，主人给我写的程序有 bug，今天运行的时候不小心崩溃了，等我再次起来时，发现管道不见了，什么情况啊？”，瘦子程序说完叹了一口气。

“那肯定不行，这匿名管道需要有亲缘关系的进程继承后才能通信，你用别的方式运行起来，肯定看不到我创建的管道啊！”

“这匿名管道用起来太麻烦了，看看还有没有别的通信方式？”

胖子程序又掏出了手册，翻了起来。

消息队列
----

“有了有了，这里还写了两种方式：命名管道、消息队列”，胖子程序说到。

“命名管道？跟匿名管道有什么区别吗？”

“命名管道有名字，有了名字就不限有亲缘关系的进程才能通信了，只要使用这个名字，都能打开管道通信，这下你就算挂了重启也能跟我联系上了”

“那消息队列又是什么东西？”

“额，让我看一下”

“给我也看看”，瘦子程序凑了上去，一起看了起来。

![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730100022730-635852687.png)

过了一会儿，瘦子程序说道：“我看明白了，这消息队列是内核中的一个消息链表，按照消息块组织，比那管道全是二进制数据流堆积在一起好用多了”

“有道理，而且这消息还可以指定类型，这样咱们俩就不用弄两个管道，一个消息队列就行了，咱们俩使用不同的消息类型，可省了不少事儿啊！”

“那咱们就用消息队列吧，别用那什么管道了”

“好，就这么干！”

两个家伙一拍即合，准备第二天再大干一场。

第二天，计算机启动后，它们又偷偷的运行了起来。

这一次用上了消息队列，联络起来方便了不少。

共享内存
----

不知过了多久，那瘦子进程总算来信儿了，胖子从消息队列中取出一看，只见上面写着：

> “老大，我拿到了数据了，需要你来处理一下，不过这数据体量有点大，用管道和消息队列传输效率都太低了，有无办法快速把数据传送给你，盼速回。”

胖子进程心里一阵欢喜，数据拿到了，总算可以回去交差了。不过怎么样快速把数据传送过来呢，心里又犯起了嘀咕。

此时，胖子进程又一次拿出手册，翻到了最后一页，发现了一个叫 “**共享内存**” 的东西，仿佛像抓住了救命稻草一般，仔细研究了起来。

片刻之后，胖子的脸上露出了笑容，随后写下了一条消息给瘦子进程发送了过去。

却说这瘦子进程正在焦急等待消息中，收到老大的回信后，赶紧取出来看：

> 二弟，主人的手册中提到，可以使用共享内存进行进程间通信。
> 
> 我准备了几个内存页面，你将它们映射到你的进程地址空间中，咱们就能共享这一片内存，你写的数据我能立即看到，我写的你也能立即看到，虽然咱们各自读写的地址不同，但实际上是访问的同一片物理内存页面，比管道和消息队列效率高多了！
> 
> ![](https://img2020.cnblogs.com/blog/659280/202107/659280-20210730100036770-1673416558.png)
> 
> 不过为了防止咱们一起读写发生冲突，需要配合**信号量**一起使用，用它来实现进程间同步。
> 
> 具体的使用方法如下：
> 
> ······
> 
> ······
> 
> 盼速回！

瘦子进程看完，心中大喜！赶紧通过消息队列发了一封回信。

随后，通过老大交代的方法开始操作起来，打开共享、映射挂载一气呵成。再接着，将数据一股脑儿写到了共享的内存页面中。

大功告成之后，便退出了进程，按照计划准备撤退，却不见了胖子的踪迹，既无进程也无文件。

“这家伙难道抛下我一个人跑了？”

正想着，突然 “嗡” 的一声，瘦子的程序文件也没了。

却看那文件目录之下，只留了一卷《Linux 进程间通信手册》···

相关推荐
----

[一个故事看懂 Redis](https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247486528&idx=1&sn=3f7b09eb21969fdb16f5b0805ff69fed&scene=21#wechat_redirect)

[一个故事看懂 Docker](https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247487647&idx=1&sn=87275d2f356de79391afa13c137e9a86&scene=21#wechat_redirect)

[一个故事看懂 CPU 中断技术](https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect)